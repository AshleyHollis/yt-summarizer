# =============================================================================
# Preview Workflow - Deploy PR Preview Environment
# =============================================================================
# Deploys preview environment using images already built by CI workflow
# Argo CD ApplicationSet with Pull Request Generator picks up the changes
# Runs E2E tests after deployment to validate changes
# Runs on PR opened/synchronize/reopened after CI passes

name: Preview

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
    # Note: paths-ignore checks entire PR diff, not latest commit
    # We use commit-level detection in detect-changes job for efficiency

concurrency:
  group: preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  ACR_NAME: ${{ vars.ACR_NAME || 'acrytsummprd' }}
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
  MAX_PREVIEWS: 3

permissions:
  id-token: write
  contents: write
  pull-requests: write
  checks: write

jobs:
  # ---------------------------------------------------------------------------
  # Detect Changes (commit-level check for docs-only changes)
  # ---------------------------------------------------------------------------
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      has_code_changes: ${{ steps.check.outputs.has_code_changes }}
    steps:
      - name: Check if commit has code changes
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get files changed in the PR (all commits) and allow manual override via label
          PR_NUMBER=${{ github.event.pull_request.number }}
          echo "Checking PR: ${PR_NUMBER}"

          # Fetch all changed files in the PR (across all commits)
          FILES=$(gh api repos/${{ github.repository }}/pulls/${PR_NUMBER}/files --jq '.[] .filename')

          echo "Files changed in this PR:"
          echo "$FILES"

          # Optional override: if PR has a 'preview' or 'force-preview' label, run preview regardless
          HAS_CODE=false
          LABELS=$(gh api repos/${{ github.repository }}/issues/${PR_NUMBER} --jq '.labels[].name') || LABELS=""
          for lbl in $LABELS; do
            if [[ "$lbl" == "preview" ]] || [[ "$lbl" == "force-preview" ]]; then
              echo "üîî Force preview label detected: $lbl"
              HAS_CODE=true
            fi
          done

          # Check if any file is NOT docs/specs/markdown
          while IFS= read -r file; do
            if [[ -n "$file" ]]; then
              # Skip docs, specs, and markdown files
              if [[ "$file" == docs/* ]] || [[ "$file" == specs/* ]] || [[ "$file" == *.md ]]; then
                echo "  [skip] $file (docs/specs/markdown)"
              else
                echo "  [CODE] $file"
                HAS_CODE=true
              fi
            fi
          done <<< "$FILES"

          echo "has_code_changes=$HAS_CODE" >> $GITHUB_OUTPUT

          if [ "$HAS_CODE" = "true" ]; then
            echo "‚úÖ PR contains code changes or force-preview label - proceeding with preview"
          else
            echo "üìù PR only contains docs/specs/markdown - skipping preview"
          fi

  # ---------------------------------------------------------------------------
  # Wait for CI to Pass (CI builds and pushes images)
  # ---------------------------------------------------------------------------
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_code_changes == 'true'
    outputs:
      image_tag: ${{ steps.image-tag.outputs.image_tag }}
    steps:
      - name: Wait for CI workflow
        uses: fountainhead/action-wait-for-check@v1.2.0
        id: wait-for-ci
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          checkName: CI Status
          ref: ${{ github.event.pull_request.head.sha }}
          timeoutSeconds: 900
          intervalSeconds: 30

      - name: Fail if CI did not pass
        if: steps.wait-for-ci.outputs.conclusion != 'success'
        run: |
          echo "::error::CI workflow did not pass. Preview deployment blocked."
          exit 1

      - name: Determine image tag from CI
        id: image-tag
        run: |
          # CI uses this tag format for PRs
          SHORT_SHA=$(echo "${{ github.event.pull_request.head.sha }}" | cut -c1-7)
          IMAGE_TAG="pr-${{ github.event.pull_request.number }}-${SHORT_SHA}"

          # Fail if for some reason the image tag couldn't be computed
          if [ -z "${IMAGE_TAG}" ]; then
            echo "::error::Computed IMAGE_TAG is empty; aborting"
            exit 1
          fi

          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Using image tag from CI: ${IMAGE_TAG}"

  # ---------------------------------------------------------------------------
  # Check Active Preview Count
  # ---------------------------------------------------------------------------
  check-concurrency:
    name: Check Preview Limit
    runs-on: ubuntu-latest
    needs: wait-for-ci
    outputs:
      can_deploy: ${{ steps.check.outputs.can_deploy }}
      image_tag: ${{ steps.export-image.outputs.image_tag }}
    steps:
      - name: Count active previews via GitHub API
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Count open PRs (each gets a preview via ApplicationSet PR Generator)
          OPEN_PRS=$(gh api repos/${{ github.repository }}/pulls --jq 'length')
          PR_NUMBER=${{ github.event.pull_request.number }}
          
          echo "Open PRs: ${OPEN_PRS}"
          echo "Max previews: ${{ env.MAX_PREVIEWS }}"
          
          # This PR is already counted in open PRs, so we compare with <=
          if [ "$OPEN_PRS" -le "${{ env.MAX_PREVIEWS }}" ]; then
            echo "Preview slot available (${OPEN_PRS}/${{ env.MAX_PREVIEWS }})"
            echo "can_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::Maximum previews reached (${OPEN_PRS}/${{ env.MAX_PREVIEWS }}). Waiting for slot..."
            echo "can_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Export computed image tag
        id: export-image
        run: |
          # Ensure we explicitly expose the image tag (propagates across jobs reliably)
          echo "image_tag=${{ needs.wait-for-ci.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "Exported image tag: ${{ needs.wait-for-ci.outputs.image_tag }}"

      - name: Post queue status
        if: steps.check.outputs.can_deploy == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚è≥ **Preview Queued**\n\nMaximum concurrent previews (${{ env.MAX_PREVIEWS }}) reached. Your preview will deploy when a slot becomes available.\n\nClose another PR or wait for an existing preview to be cleaned up.`
            })

  # ---------------------------------------------------------------------------
  # Update Preview Overlay in PR Branch
  # ---------------------------------------------------------------------------
  get-ingress:
    name: Get Ingress Info
    runs-on: ubuntu-latest
    needs: check-concurrency
    if: needs.check-concurrency.outputs.can_deploy == 'true'
    outputs:
      ingress_ip: ${{ steps.ingress-ip.outputs.ip }}
      preview_url: ${{ steps.preview.outputs.preview_url }}
      preview_host: ${{ steps.preview.outputs.preview_host }}
      tls_secret: ${{ steps.preview.outputs.tls_secret }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AZURE_AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Get Ingress Controller IP
        id: ingress-ip
        run: |
          INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Found Ingress IP: $INGRESS_IP"
          echo "ip=$INGRESS_IP" >> $GITHUB_OUTPUT

      - name: Compute preview host + URL + TLS secret
        id: preview
        env:
          INGRESS_IP: ${{ steps.ingress-ip.outputs.ip }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          if [ -n "$INGRESS_IP" ]; then
            IP_DASHED=$(echo "$INGRESS_IP" | tr '.' '-')
            PREVIEW_HOST="api.preview-pr-${PR_NUMBER}.${IP_DASHED}.nip.io"
            # CRITICAL: Must use HTTPS to avoid mixed content errors
            # Frontend is served over HTTPS from Azure Static Web Apps
            # Browsers block HTTP requests from HTTPS pages
            # Ensure ingress uses cert-manager.io/cluster-issuer: letsencrypt-prod (not staging!)
            PREVIEW_URL="https://${PREVIEW_HOST}"
            TLS_SECRET="preview-pr-${PR_NUMBER}-tls"
            echo "‚úÖ Using dynamic Preview Host: ${PREVIEW_HOST} -> ${PREVIEW_URL}"
          else
            PREVIEW_URL=""
            PREVIEW_HOST=""
            TLS_SECRET=""
            echo "‚ö†Ô∏è Ingress IP not found"
          fi
          echo "preview_url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "preview_host=${PREVIEW_HOST}" >> $GITHUB_OUTPUT
          echo "tls_secret=${TLS_SECRET}" >> $GITHUB_OUTPUT

  update-overlay:
    name: Update Preview Overlay
    runs-on: ubuntu-latest
    needs: [check-concurrency, get-ingress]
    if: needs.check-concurrency.outputs.can_deploy == 'true'
    outputs:
      preview_url: ${{ steps.overlay.outputs.preview_url }}
      image_tag: ${{ needs.check-concurrency.outputs.image_tag }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AZURE_AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Get Ingress Controller IP
        id: ingress-ip
        run: |
          INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Found Ingress IP: $INGRESS_IP"
          echo "ip=$INGRESS_IP" >> $GITHUB_OUTPUT

      - name: Update preview overlay with image tags
        id: overlay
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          IMAGE_TAG: ${{ needs.check-concurrency.outputs.image_tag }}
          ACR_SERVER: ${{ env.ACR_LOGIN_SERVER }}
          INGRESS_IP: ${{ steps.ingress-ip.outputs.ip }}
        run: |
          OVERLAY_FILE="k8s/overlays/preview/kustomization.yaml"
          
          # Check if preview overlay exists
          if [ ! -f "$OVERLAY_FILE" ]; then
            echo "::error::Preview overlay not found at ${OVERLAY_FILE}"
            echo "::error::Ensure k8s/overlays/preview/ exists in your PR branch"
            exit 1
          fi

          # Fail early if IMAGE_TAG is empty - prevents committing empty newTag values
          # and avoids Argo CD deploying images without tags.
          if [ -z "${IMAGE_TAG}" ]; then
            echo "::error::IMAGE_TAG is empty. Aborting to avoid committing empty tags into ${OVERLAY_FILE}"
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Debug: show the computed image tag
          echo "Using IMAGE_TAG=${IMAGE_TAG}"
          
          # Update image tags in kustomization.yaml using Python script
          python scripts/ci/generate_preview_kustomization.py \
            --template scripts/ci/templates/preview-kustomization-template.yaml \
            --output "$OVERLAY_FILE" \
            --pr-number "${PR_NUMBER}" \
            --image-tag "${IMAGE_TAG}" \
            --acr-server "${ACR_SERVER}"
          
          # Use preview info from get-ingress job outputs
          PREVIEW_URL="${{ needs.get-ingress.outputs.preview_url }}"
          PREVIEW_HOST="${{ needs.get-ingress.outputs.preview_host }}"
          TLS_SECRET="${{ needs.get-ingress.outputs.tls_secret }}"
          if [ -n "$PREVIEW_URL" ]; then
            echo "‚úÖ Using Preview URL: ${PREVIEW_URL}"
            # Pass preview details into the generator so it can substitute placeholders in patches
            python scripts/ci/generate_preview_kustomization.py \
              --template scripts/ci/templates/preview-kustomization-template.yaml \
              --output "$OVERLAY_FILE" \
              --pr-number "${PR_NUMBER}" \
              --image-tag "${IMAGE_TAG}" \
              --acr-server "${ACR_SERVER}" \
              --preview-host "${PREVIEW_HOST}" \
              --tls-secret "${TLS_SECRET}" || true
          else
            echo "‚ö†Ô∏è PREVIEW_API_URL not configured and Ingress IP not found"
            echo "::warning::Backend connectivity may be broken"
          fi

          echo "preview_url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "preview_host=${PREVIEW_HOST:-}" >> $GITHUB_OUTPUT
          echo "tls_secret=${TLS_SECRET:-}" >> $GITHUB_OUTPUT
          
          echo "Updated preview overlay at ${OVERLAY_FILE}"
          cat "$OVERLAY_FILE"

      - name: Install kustomize
        uses: imranismail/setup-kustomize@v3
        with:
          kustomize-version: '5.8.0'

      - name: Validate generated overlay (kustomize + dry-run)
        run: |
          set -eo pipefail
          OVERLAY_FILE="k8s/overlays/preview/kustomization.yaml"
          TMP_MANIFEST="/tmp/preview-manifests.yaml"
          ERR_FILE="/tmp/kustomize.err"

          echo "--- Git status / branch / commit ---"
          git rev-parse --abbrev-ref HEAD || true
          git status --porcelain -b || true
          git log -1 --pretty=oneline || true

          echo "--- Overlay file (post-generation) ---"
          if [ -f "$OVERLAY_FILE" ]; then
            echo "file size: $(wc -c < "$OVERLAY_FILE") bytes" || true
            echo "first bytes (hex):"; if command -v xxd >/dev/null 2>&1; then xxd -g 1 -l 32 "$OVERLAY_FILE" || true; else head -c 32 "$OVERLAY_FILE" | od -An -t x1 || true; fi
            cat -n "$OVERLAY_FILE" | sed -n '1,200p' || true
          else
            echo "(overlay file not found)"
          fi

          echo "--- Listing patch files (k8s/overlays/preview/patches) ---"
          ls -la k8s/overlays/preview/patches || true
          for f in k8s/overlays/preview/patches/*; do
            echo "--- $f (first 200 lines) ---"
            echo "first bytes (hex):"; if command -v xxd >/dev/null 2>&1; then xxd -g 1 -l 32 "$f" || true; else head -c 32 "$f" | od -An -t x1 || true; fi
            cat -n "$f" | sed -n '1,200p' || true
          done || true

          echo "--- Show overlay file as committed in HEAD (if present) ---"
          git show HEAD:$OVERLAY_FILE || echo "(no file in HEAD at path)"

          echo "Building manifests with kustomize..."
          if ! kustomize build k8s/overlays/preview > "$TMP_MANIFEST" 2> "$ERR_FILE"; then
            echo "::error::kustomize build FAILED for overlay 'preview'"
            echo "--- kustomize stderr ---"
            sed -n '1,200p' "$ERR_FILE" || true
            echo "--- end kustomize stderr ---"

            echo "--- Generated overlay file (again) ---"
            if [ -f "$OVERLAY_FILE" ]; then
              echo "file size: $(wc -c < "$OVERLAY_FILE") bytes" || true
              echo "first bytes (hex):"; if command -v xxd >/dev/null 2>&1; then xxd -g 1 -l 32 "$OVERLAY_FILE" || true; else head -c 32 "$OVERLAY_FILE" | od -An -t x1 || true; fi
              cat -n "$OVERLAY_FILE" | sed -n '1,200p' || true
            else
              echo "(overlay file not found)"
            fi

            echo "--- Listing patch files (k8s/overlays/preview/patches) ---"
            ls -la k8s/overlays/preview/patches || true
            for f in k8s/overlays/preview/patches/*; do
              echo "--- $f (first 200 lines) ---"
              echo "first bytes (hex):"; if command -v xxd >/dev/null 2>&1; then xxd -g 1 -l 32 "$f" || true; else head -c 32 "$f" | od -An -t x1 || true; fi
              cat -n "$f" | sed -n '1,200p' || true
            done || true

            echo "Searching for 'group:' occurrences (common cause of 'unknown field \"group\"')"
            grep -n "^\s*group:\s" "$OVERLAY_FILE" || true
            grep -n "^\s*group:\s" k8s/overlays/preview/patches/* || true

            echo "::error::kustomize build failed for overlay 'preview' - see log and files above for diagnostics"
            exit 1
          fi

          echo "Checking YAML syntax by parsing manifests..."
          python scripts/ci/parse_yaml.py "$TMP_MANIFEST"

          echo "Performing server-side dry-run apply to validate against API server..."
          if kubectl apply --server-dry-run=server -f "$TMP_MANIFEST"; then
            echo "Server dry-run OK"
          else
            echo "::error::Server dry-run failed - printing manifest and exiting"
            sed -n '1,200p' "$ERR_FILE" || true
            cat -n "$OVERLAY_FILE" | sed -n '1,200p' || true
            cat "$TMP_MANIFEST" | sed -n '1,200p' || true
            exit 1
          fi

      - name: Commit and push overlay update
        env:
          IMAGE_TAG: ${{ needs.check-concurrency.outputs.image_tag }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Sanity: ensure generated overlay contains a non-empty newTag
          if grep -q "newTag: \"\"" k8s/overlays/preview/kustomization.yaml; then
            echo "::error::Generated overlay has empty newTag - aborting commit"
            echo "--- overlay ---"
            cat k8s/overlays/preview/kustomization.yaml
            echo "--- end overlay ---"
            exit 1
          fi

          git add k8s/overlays/preview/
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore(preview): update image tags for PR #${PR_NUMBER}
            
            Image tag: ${IMAGE_TAG}
            Commit: ${{ github.event.pull_request.head.sha }}
            
            [skip ci]"
            
            git push origin ${{ github.event.pull_request.head.ref }}
          fi

  # ---------------------------------------------------------------------------
  # Verify Deployment
  # ---------------------------------------------------------------------------
  # Waits for Argo CD to sync and verifies pods are running the correct images
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [update-overlay, check-concurrency]
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Wait for Argo CD to sync
        env:
          NAMESPACE: preview-pr-${{ github.event.pull_request.number }}
          EXPECTED_TAG: ${{ needs.check-concurrency.outputs.image_tag }}
        run: |
          echo "Waiting for Argo CD to sync preview environment..."
          echo "Expected image tag: ${EXPECTED_TAG}"
          echo "Namespace: ${NAMESPACE}"
          
          # Wait up to 3 minutes for Argo CD to create/update the namespace
          for i in {1..36}; do
            if kubectl get namespace ${NAMESPACE} 2>/dev/null; then
              echo "‚úÖ Namespace ${NAMESPACE} exists"
              break
            fi
            echo "  Attempt $i/36 - Namespace not found, waiting 5s..."
            sleep 5
          done
          
          if ! kubectl get namespace ${NAMESPACE} 2>/dev/null; then
            echo "::error::Namespace ${NAMESPACE} was not created by Argo CD after 3 minutes"

            # Try to gather Argo CD Application status for diagnostics
            APP_NAME="preview-pr-${{ github.event.pull_request.number }}"
            echo "Attempting to fetch Argo CD Application status for ${APP_NAME} (namespace: argocd)"
            echo "--- Argo CD Application (yaml) ---"
            kubectl get applications.argoproj.io ${APP_NAME} -n argocd -o yaml || echo "No Argo CD application named ${APP_NAME} found in namespace 'argocd'"
            echo "--- Argo CD application events / status (describe) ---"
            kubectl describe application ${APP_NAME} -n argocd || true

            echo "--- Argo CD applications matching preview-pr-${{ github.event.pull_request.number }} (all namespaces) ---"
            kubectl get applications.argoproj.io --all-namespaces | grep "preview-pr-${{ github.event.pull_request.number }}" || true

            exit 1
          fi

      - name: Verify API deployment image
        env:
          NAMESPACE: preview-pr-${{ github.event.pull_request.number }}
          EXPECTED_TAG: ${{ needs.check-concurrency.outputs.image_tag }}
          REGISTRY: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
        run: |
          echo "Waiting for API deployment to be ready..."
          
          # Wait up to 5 minutes for the deployment to exist and be ready
          for i in {1..60}; do
            if kubectl get deployment api -n ${NAMESPACE} 2>/dev/null; then
              echo "‚úÖ API deployment exists"
              
              # Get the current image
              CURRENT_IMAGE=$(kubectl get deployment api -n ${NAMESPACE} -o jsonpath='{.spec.template.spec.containers[0].image}')
              echo "Current image: ${CURRENT_IMAGE}"
              echo "Expected: ${REGISTRY}/yt-summarizer-api:${EXPECTED_TAG}"
              
              # Check if it matches expected tag
              if [[ "${CURRENT_IMAGE}" == "${REGISTRY}/yt-summarizer-api:${EXPECTED_TAG}" ]]; then
                echo "‚úÖ API deployment is using the correct image tag"
                
                # Wait for deployment to be ready
                if kubectl rollout status deployment/api -n ${NAMESPACE} --timeout=120s; then
                  echo "‚úÖ API deployment is ready"
                  exit 0
                fi
              else
                echo "‚ö†Ô∏è Image tag mismatch - Argo CD may still be syncing"
              fi
            fi
            
            echo "  Attempt $i/60 - Waiting for deployment, 5s..."
            sleep 5
          done
          
          echo "::error::API deployment did not reach ready state with correct image after 5 minutes"
          kubectl get deployment api -n ${NAMESPACE} -o yaml || true
          exit 1

      - name: Verify workers deployment image
        env:
          NAMESPACE: preview-pr-${{ github.event.pull_request.number }}
          EXPECTED_TAG: ${{ needs.check-concurrency.outputs.image_tag }}
          REGISTRY: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
        run: |
          echo "Verifying worker deployments..."
          
          for WORKER in transcribe-worker summarize-worker embed-worker relationships-worker; do
            echo "Checking ${WORKER}..."
            
            CURRENT_IMAGE=$(kubectl get deployment ${WORKER} -n ${NAMESPACE} -o jsonpath='{.spec.template.spec.containers[0].image}')
            echo "  Current image: ${CURRENT_IMAGE}"
            
            if [[ "${CURRENT_IMAGE}" == "${REGISTRY}/yt-summarizer-workers:${EXPECTED_TAG}" ]]; then
              echo "  ‚úÖ ${WORKER} is using the correct image tag"
            else
              echo "  ::warning::${WORKER} image mismatch: ${CURRENT_IMAGE}"
            fi
          done

      - name: Run basic API health check
        env:
          NAMESPACE: preview-pr-${{ github.event.pull_request.number }}
          API_URL: ${{ needs.update-overlay.outputs.preview_url }}
        run: |
          if [ -n "$API_URL" ]; then
            echo "Running health check against ${API_URL}/health/live"
            
            # Try health check with retries
            for i in {1..10}; do
              if curl -sf "${API_URL}/health/live" | grep -q "ok"; then
                echo "‚úÖ API health check passed"
                exit 0
              fi
              echo "  Attempt $i/10 - API not ready, waiting 10s..."
              sleep 10
            done
            
            echo "::warning::API health check failed after 10 attempts"
            echo "This may be a transient issue - check logs in the pod"
          else
            echo "::warning::No API URL configured - skipping health check"
          fi

      - name: Verify API Certificate
        env:
          API_HOST: ${{ needs.get-ingress.outputs.preview_host }}
        run: |
          if [ -n "$API_HOST" ]; then
            echo "Verifying certificate for ${API_HOST}"
            
            # Use openssl to check certificate chain and validity
            CERT_OUTPUT=$(echo | openssl s_client -connect ${API_HOST}:443 -servername ${API_HOST} 2>/dev/null | openssl x509 -noout -text)
            
            if [ $? -ne 0 ]; then
              echo "::error::Failed to retrieve certificate from ${API_HOST}"
              exit 1
            fi
            
            # Check if certificate is not expired
            if echo "$CERT_OUTPUT" | grep -q "Not Before:" && echo "$CERT_OUTPUT" | grep -q "Not After:"; then
              echo "‚úÖ Certificate dates found"
            else
              echo "::error::Certificate missing validity dates"
              exit 1
            fi
            
            # Check for Let's Encrypt R3 intermediate (common issue we've seen)
            if echo "$CERT_OUTPUT" | grep -q "Issuer: C=US, O=Let's Encrypt, CN=R3"; then
              echo "‚úÖ Let's Encrypt R3 intermediate certificate detected"
            else
              echo "::warning::Let's Encrypt R3 intermediate not found in certificate chain"
              echo "This may indicate an incomplete certificate chain"
            fi
            
            # Check certificate validity period
            NOT_BEFORE=$(echo "$CERT_OUTPUT" | grep "Not Before:" | sed 's/.*Not Before: //')
            NOT_AFTER=$(echo "$CERT_OUTPUT" | grep "Not After:" | sed 's/.*Not After: //')
            
            echo "Certificate valid from: ${NOT_BEFORE}"
            echo "Certificate valid until: ${NOT_AFTER}"
            
            # Check if certificate is currently valid
            CURRENT_TIME=$(date +%s)
            NOT_AFTER_EPOCH=$(date -d "$NOT_AFTER" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$NOT_AFTER" +%s 2>/dev/null)
            
            if [ -n "$NOT_AFTER_EPOCH" ] && [ $CURRENT_TIME -lt $NOT_AFTER_EPOCH ]; then
              echo "‚úÖ Certificate is not expired"
            else
              echo "::error::Certificate appears to be expired or invalid date format"
              exit 1
            fi
            
            echo "‚úÖ Certificate verification passed"
          else
            echo "::warning::No API host configured - skipping certificate verification"
          fi

  # ---------------------------------------------------------------------------
  # Deploy Frontend Preview to SWA
  # ---------------------------------------------------------------------------
  deploy-frontend-preview:
    name: Deploy Frontend Preview
    runs-on: ubuntu-latest
    needs: get-ingress
    outputs:
      frontend_preview_url: ${{ steps.deploy.outputs.static_web_app_url }}
    steps:
      - name: Verify SWA token is configured
        env:
          SWA_TOKEN: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
        run: |
          if [ -z "$SWA_TOKEN" ]; then
            echo "::error::SWA_DEPLOYMENT_TOKEN secret is not configured. Please add it to repository secrets."
            exit 1
          fi
          echo "‚úÖ SWA deployment token is configured"

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: "20"
          working-directory: apps/web

      - name: Build frontend for preview
        working-directory: apps/web
        env:
          # Set the backend API URL directly (SWA doesn't support Next.js rewrites)
          NEXT_PUBLIC_API_URL: ${{ needs.get-ingress.outputs.preview_url }}
          NEXT_PUBLIC_ENVIRONMENT: preview
        run: |
          if [ -z "$NEXT_PUBLIC_API_URL" ]; then
            echo "::warning::Building frontend without backend API URL"
          else
            echo "Building frontend with API URL: $NEXT_PUBLIC_API_URL"
          fi
          npm run build

      - name: Deploy to SWA staging environment
        id: deploy
        uses: Azure/static-web-apps-deploy@v1
        env:
          # Set the backend API URL for runtime
          NEXT_PUBLIC_API_URL: ${{ needs.get-ingress.outputs.preview_url || '' }}
          NEXT_PUBLIC_ENVIRONMENT: preview
        with:
          azure_static_web_apps_api_token: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: upload
          # For Next.js hybrid, app_location is the Next.js app root
          app_location: apps/web
          # For Next.js hybrid, output_location MUST be empty
          # SWA handles the .next folder internally
          output_location: ""
          skip_app_build: true
          # Deploying to a PR creates a staging environment automatically
          production_branch: main

  # ---------------------------------------------------------------------------
  # Post Preview Comment
  # ---------------------------------------------------------------------------
  # Posts preview information to the PR for reviewers (human-facing).
  # This is intentionally separate from the preview status check to avoid
  # blocking merges if posting a comment fails.
  post-preview-comment:
    name: Post Preview Comment
    runs-on: ubuntu-latest
    needs: [update-overlay, verify-deployment, deploy-frontend-preview]
    steps:
      - name: Post preview URL to PR
        uses: actions/github-script@v7
        with:
          script: |
            const backendUrl = '${{ needs.get-ingress.outputs.preview_url }}';
            const frontendUrl = '${{ needs.deploy-frontend-preview.outputs.frontend_preview_url }}' || 'Deploying...';
            const imageTag = '${{ needs.update-overlay.outputs.image_tag }}';
            const sha = '${{ github.event.pull_request.head.sha }}'.substring(0, 7);
            const prNumber = ${{ github.event.pull_request.number }};
            
            // Find and update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Preview Environment')
            );
            
            const frontendLink = frontendUrl.startsWith('http') 
              ? `[${frontendUrl}](${frontendUrl})` 
              : frontendUrl;
            
            const body = `## üöÄ Preview Environment

            | Property | Value |
            |----------|-------|
            | **Status** | ‚úÖ Deployed |
            | **Frontend** | ${frontendLink} |
            | **Backend API** | [${backendUrl}](${backendUrl}) |
            | **API Health** | [${backendUrl}/health](${backendUrl}/health) |
            | **Image Tag** | \`${imageTag}\` |
            | **Commit** | \`${sha}\` |
            | **Updated** | ${new Date().toISOString()} |

            > üîÑ This preview will be automatically updated when you push new commits.
            > üóëÔ∏è Preview will be cleaned up automatically when this PR is closed or merged.
            
            ---
            <details>
            <summary>üîß Architecture Details</summary>
            
            **Frontend**: Deployed to Azure Static Web Apps staging environment
            **Backend**: Deployed to AKS via Argo CD ApplicationSet with Pull Request Generator
            
            The overlay lives in your PR branch at \`k8s/overlays/preview/\`.
            
            Application name: \`preview-pr-${prNumber}\`
            Namespace: \`preview-pr-${prNumber}\`
            </details>`;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

      - name: Create deployment summary
        run: |
          echo "## üöÄ Preview Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **PR** | #${{ github.event.pull_request.number }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Preview URL** | ${{ needs.get-ingress.outputs.preview_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | \`${{ needs.update-overlay.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.event.pull_request.head.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Quick Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Preview Site](${{ needs.get-ingress.outputs.preview_url }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚ÑπÔ∏è Architecture" >> $GITHUB_STEP_SUMMARY
          echo "This preview uses Argo CD ApplicationSet with Pull Request Generator." >> $GITHUB_STEP_SUMMARY
          echo "The overlay at \`k8s/overlays/preview/\` lives in your PR branch." >> $GITHUB_STEP_SUMMARY
          echo "Argo CD automatically discovers open PRs and creates preview environments." >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # E2E Tests on Preview Environment
  # ---------------------------------------------------------------------------
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [update-overlay, verify-deployment, deploy-frontend-preview, post-preview-comment]
    # Skip E2E tests if no API URL is configured
    if: needs.get-ingress.outputs.preview_url != ''
    outputs:
      result: ${{ steps.run-tests.outcome }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: 'npm'
          cache-dependency-path: apps/web/package-lock.json

      - name: Install dependencies
        working-directory: apps/web
        run: npm ci

      - name: Install Playwright browsers
        working-directory: apps/web
        run: npx playwright install --with-deps chromium

      - name: Wait for preview environment to be ready
        env:
          PREVIEW_URL: ${{ needs.get-ingress.outputs.preview_url }}
          FRONTEND_URL: ${{ needs.deploy-frontend-preview.outputs.frontend_preview_url }}
        run: |
          # Determine which URL to use for frontend
          if [ -n "$FRONTEND_URL" ] && [ "$FRONTEND_URL" != "" ]; then
            FRONTEND_CHECK_URL="$FRONTEND_URL"
          else
            FRONTEND_CHECK_URL="$PREVIEW_URL"
          fi
          
          echo "Waiting for preview environment to be ready..."
          echo "Frontend URL: $FRONTEND_CHECK_URL"
          echo "API URL: $PREVIEW_URL"
          
          # Wait for Argo CD to sync (allow up to 5 minutes)
          echo "Waiting 60 seconds for Argo CD to sync..."
          sleep 60
          
          # Wait for API to be ready
          for i in {1..20}; do
            if curl -sf "${PREVIEW_URL}/health/live" > /dev/null 2>&1; then
              echo "‚úì API is ready"
              break
            fi
            echo "  Attempt $i/20 - API not ready, waiting 15s..."
            sleep 15
          done

      - name: Run E2E tests
        id: run-tests
        working-directory: apps/web
        env:
          USE_EXTERNAL_SERVER: "true"
          BASE_URL: ${{ needs.deploy-frontend-preview.outputs.frontend_preview_url || needs.get-ingress.outputs.preview_url }}
          NEXT_PUBLIC_API_URL: ${{ needs.get-ingress.outputs.preview_url }}
          API_URL: ${{ needs.get-ingress.outputs.preview_url }}
        run: npx playwright test --reporter=html

      - name: Upload Playwright report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report-pr-${{ github.event.pull_request.number }}
          path: apps/web/playwright-report/
          retention-days: 7

      - name: Comment E2E results on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.run-tests.outcome }}' === 'success' ? '‚úÖ Passed' : '‚ùå Failed';
            const emoji = '${{ steps.run-tests.outcome }}' === 'success' ? '‚úÖ' : '‚ùå';
            const reportUrl = `https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            // Find existing E2E comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const e2eComment = comments.find(c => 
              c.user.type === 'Bot' && 
              c.body.includes('E2E Test Results')
            );
            
            const body = `## ${emoji} E2E Test Results\n\n` +
              `| Property | Value |\n` +
              `|----------|-------|\n` +
              `| **Status** | ${status} |\n` +
              `| **Environment** | ${{ needs.get-ingress.outputs.preview_url }} |\n` +
              `| **Commit** | \`${{ github.event.pull_request.head.sha }}\` |\n\n` +
              `[üìä View Playwright Report](${reportUrl})`;
            
            if (e2eComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: e2eComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

  # ---------------------------------------------------------------------------
  # Preview Status Check - Required Check for Merge
  # ---------------------------------------------------------------------------
  # Aggregates preview job results and produces a single, deterministic
  # required check used to gate merges (machine-facing/gating).
  # E2E tests are optional (skipped if no backend API URL is configured).
  # ---------------------------------------------------------------------------
  preview-status-check:
    name: Preview Status Check
    runs-on: ubuntu-latest
    needs: [detect-changes, update-overlay, verify-deployment, deploy-frontend-preview, e2e-tests]
    if: always()
    steps:
      - name: Check preview pipeline status
        env:
          API_URL_CONFIGURED: ${{ needs.get-ingress.outputs.preview_url }}
        run: |
          echo "## Preview Pipeline Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # If no code changes, mark as success (docs-only PR)
          if [ "${{ needs.detect-changes.outputs.has_code_changes }}" != "true" ]; then
            echo "üìù No code changes detected - docs-only PR"
            echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
            echo "| Detect Changes | ‚úÖ Docs-only |" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # Determine E2E test status display
          E2E_RESULT="${{ needs.e2e-tests.result }}"
          if [ -z "$API_URL_CONFIGURED" ]; then
            E2E_STATUS="‚è≠Ô∏è Skipped (no API URL)"
            E2E_REQUIRED=false
          elif [ "$E2E_RESULT" = "success" ]; then
            E2E_STATUS="‚úÖ Passed"
            E2E_REQUIRED=true
          elif [ "$E2E_RESULT" = "skipped" ]; then
            E2E_STATUS="‚è≠Ô∏è Skipped"
            E2E_REQUIRED=false
          else
            E2E_STATUS="‚ùå Failed"
            E2E_REQUIRED=true
          fi
          
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Update Overlay | ${{ needs.update-overlay.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Verify Deployment | ${{ needs.verify-deployment.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Frontend | ${{ needs.deploy-frontend-preview.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| E2E Tests | ${E2E_STATUS} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Required jobs must succeed only if the PR contains code changes
          if [ "${{ needs.detect-changes.outputs.has_code_changes }}" = "true" ] && [ "${{ needs.update-overlay.result }}" != "success" ]; then
            echo "::error::Update overlay failed"
            exit 1
          fi

          if [ "${{ needs.detect-changes.outputs.has_code_changes }}" = "true" ] && [ "${{ needs.verify-deployment.result }}" != "success" ]; then
            echo "::error::Deployment verification failed - pods may not be running correct image"
            exit 1
          fi

          if [ "${{ needs.detect-changes.outputs.has_code_changes }}" = "true" ] && [ "${{ needs.deploy-frontend-preview.result }}" != "success" ]; then
            echo "::error::Frontend deployment failed"
            exit 1
          fi
          
          # E2E tests only required if API URL is configured
          if [ "$E2E_REQUIRED" = "true" ] && [ "$E2E_RESULT" != "success" ]; then
            echo "::error::E2E tests failed"
            exit 1
          fi
          
          if [ -z "$API_URL_CONFIGURED" ]; then
            echo "‚ö†Ô∏è Preview deployed without backend API" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To enable full preview functionality:" >> $GITHUB_STEP_SUMMARY
            echo "1. Set \`PREVIEW_API_URL\` in repository variables" >> $GITHUB_STEP_SUMMARY
            echo "2. Re-run this workflow" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "‚úÖ Preview pipeline completed successfully!" >> $GITHUB_STEP_SUMMARY
