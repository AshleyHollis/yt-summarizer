# =============================================================================
# Preview Deployment Workflow
# =============================================================================
# TRIGGERS: PR opened/updated, manual dispatch
#
# EXECUTION FLOWS:
# 1. Code Changes ‚Üí Wait for CI images ‚Üí Deploy to AKS + SWA ‚Üí Run E2E
# 2. K8s Only Changes ‚Üí Use existing images ‚Üí Deploy k8s updates only
# 3. No Changes ‚Üí Skip (unless force_deploy=true)
# 4. Max Previews Reached ‚Üí Queue (wait for slot)
#
# ARCHITECTURE:
# - Backend: AKS deployment via Argo CD (auto-syncs from k8s/overlays/preview/)
# - Frontend: Azure Static Web Apps (ephemeral preview per PR)
# - DNS: Cloudflare with Gateway API + TLS certificates
#
# DEPENDENCIES:
# - CI workflow MUST complete and build images before deployment
# - Image tags from CI: pr-<number>-<sha>
# - No fallback to existing images if CI fails (fail fast)
#
# IMAGE BUILD STRATEGY:
# ---------------------
# Two-path strategy based on change detection (similar to production):
#
# Path 1: CODE CHANGES (wait for CI to build images)
#   - Triggers: services/api, services/workers, services/shared, apps/web, docker
#   - CI Builds: pr-{number}-{sha} tag (e.g., pr-42-abc1234)
#   - wait-for-ci: Waits for CI workflow, extracts image tag
#   - Validates: Image exists in ACR and is pullable by AKS
#   - Updates: Preview overlay with new PR-scoped tag
#   - Result: ArgoCD deploys new code to preview namespace
#
# Path 2: K8S-ONLY CHANGES (use existing PR image)
#   - Triggers: k8s manifests (no code changes in PR)
#   - get-production-tag: Searches PR git history backwards
#   - Finds: Most recent commit in THIS PR that changed code
#   - Fallback: If no code changes in PR, uses production SHA tag
#   - Validates: Image exists in ACR
#   - Updates: Preview overlay with found tag (same image, new config)
#   - Result: ArgoCD deploys config changes only
#
# IMAGE TAG FORMAT:
#   - Preview: pr-{number}-{7-char-sha} (PR-scoped, deterministic)
#   - Example: pr-42-abc1234 (PR #42, commit abc1234)
#   - Fallback: sha-{commit} (production tag, if no PR code changes)
#
# KEY DIFFERENCES FROM PRODUCTION:
#   - Preview: Waits for CI (images built in separate workflow)
#   - Production: Builds images inline (in same workflow)
#   - Preview: PR-scoped tags (pr-42-*)
#   - Production: SHA tags (sha-*)
#   - Preview: Searches PR history for last code change
#   - Production: Reads current prod kustomization
#   - Preview: Deploys to preview-pr-{number} namespace
#   - Production: Deploys to yt-summarizer namespace
#
# RATIONALE:
#   - Deterministic: Each preview traceable to specific PR commit
#   - Efficient: Don't rebuild images for K8s-only changes
#   - Safe: Image validation ensures ACR has required tags
#   - Isolated: Each PR gets its own namespace + image tags
#   - Fast: CI builds in parallel, preview waits and deploys
#
# EXTRACTED SCRIPTS:
#   - scripts/workflows/preview-finalize-flags.sh: Finalize deployment decision
#   - scripts/workflows/preview-detect-infra.sh: Detect infrastructure changes
#   - scripts/workflows/preview-find-pr-image-tag.sh: Find most recent code-building commit
#
# See also: deploy-prod.yml for production image strategy
#           docs/preview-image-build-strategy.md for full details
#           REFACTORING.md for adding new workflow scripts
#
# =============================================================================

name: Preview Deployment

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  # Allow manual triggering for testing from any branch
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to deploy preview for (optional - will use latest commit)'
        required: false
        type: string
      force_deploy:
        description: 'Force deployment even without code changes'
        required: false
        type: boolean
        default: false
      run_preview:
        description: 'Run preview deployment jobs'
        required: false
        type: boolean
        default: true
      run_terraform:
        description: 'Run terraform plan (workflow_dispatch only)'
        required: false
        type: boolean
        default: true
      apply_terraform:
        description: 'Apply terraform changes (workflow_dispatch only)'
        required: false
        type: boolean
        default: true

      run_e2e:
        description: 'Run E2E tests'
        required: false
        type: boolean
        default: true

concurrency:
  # One preview deployment per PR at a time
  # Cancels in-progress runs when new commits pushed
  group: preview-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true


env:
  # Container Registry
  ACR_NAME: ${{ vars.ACR_NAME || 'acrytsummprd' }}
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}

  # Application Names
  APP_NAME: 'yt-summarizer'
  API_IMAGE_NAME: 'yt-summarizer-api'
  WORKERS_IMAGE_NAME: 'yt-summarizer-workers'

  # Namespaces
  NAMESPACE_ARGOCD: 'argocd'
  PREVIEW_NAMESPACE_PREFIX: 'preview-pr-'

  # Worker List
  WORKER_DEPLOYMENTS: 'transcribe-worker,summarize-worker,embed-worker,relationships-worker'

  # URLs
  APPS_BASE_DOMAIN: 'yt-summarizer.apps.ashleyhollis.com'
  HEALTH_CHECK_PATH: '/health/ready'

  # Timeouts (seconds)
  ARGOCD_SYNC_TIMEOUT: '180'
  ARGOCD_OPERATION_TIMEOUT_THRESHOLD: '300'
  HEALTH_CHECK_MAX_ATTEMPTS: '10'
  HEALTH_CHECK_INTERVAL: '15'
  HEALTH_CHECK_TIMEOUT: '30'

  # Paths
  KUSTOMIZE_OVERLAY_PREVIEW: 'k8s/overlays/preview'
  ARGOCD_MANIFESTS_PATH: 'k8s/argocd'

  # Tool Versions
  TERRAFORM_VERSION: '1.5.7'
  KUSTOMIZE_VERSION: '5.8.0'
  NODE_VERSION: '20'

  # Preview Limits
  MAX_PREVIEWS: 3

permissions:
  id-token: write
  contents: write
  pull-requests: write
  checks: write

jobs:
  # ===========================================================================
  # PHASE 1: CHANGE DETECTION & PR METADATA
  # ===========================================================================
  # Determines WHAT changed and WHETHER deployment is needed
  # Outputs:
  #   - needs_image_build: true if services/apps/docker changed (requires CI images)
  #   - needs_deployment: true if any deployment required (code or k8s changes)
  #   - pr_number, pr_head_ref, pr_head_sha: PR metadata for downstream jobs
  #
  # DECISION TREE:
  #   Code changes (services/apps/docker) ‚Üí needs_image_build=true, needs_deployment=true
  #   K8s only changes ‚Üí needs_image_build=false, needs_deployment=true
  #   No relevant changes ‚Üí both false (workflow stops)
  # ===========================================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    outputs:
      needs_image_build: ${{ steps.finalize.outputs.needs_image_build }}
      needs_deployment: ${{ steps.finalize.outputs.needs_deployment }}
      infra_changed: ${{ steps.infra.outputs.infra_changed }}
      pr_number: ${{ steps.set-pr.outputs.pr_number }}
      pr_head_ref: ${{ steps.set-pr.outputs.pr_head_ref }}
      pr_head_sha: ${{ steps.set-pr.outputs.pr_head_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git diff

      - name: Get PR metadata
        id: set-pr
        uses: ./.github/actions/get-pr-metadata
        with:
          event-name: ${{ github.event_name }}
          pr-number-input: ${{ github.event.inputs.pr_number }}
          pr-number-context: ${{ github.event.pull_request.number }}
          pr-head-ref-context: ${{ github.event.pull_request.head.ref }}
          pr-head-sha-context: ${{ github.event.pull_request.head.sha }}
          pr-base-sha-context: ${{ github.event.pull_request.base.sha }}
          current-ref: ${{ github.ref_name }}
          current-sha: ${{ github.sha }}

      - name: Check if commit has code changes
        id: check
        uses: ./.github/actions/detect-pr-code-changes
        with:
          base-sha: ${{ steps.set-pr.outputs.base_sha }}
          head-sha: ${{ steps.set-pr.outputs.pr_head_sha }}
          pr-number: ${{ steps.set-pr.outputs.pr_number }}
          force-deploy: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_deploy }}

      - name: Finalize deployment flags
        id: finalize
        shell: bash
        run: scripts/workflows/preview-finalize-flags.sh

      - name: Detect infra changes
        id: infra
        shell: bash
        run: scripts/workflows/preview-detect-infra.sh

  # ===========================================================================
  # PHASE 1B: TERRAFORM PLAN
  # ===========================================================================
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: detect-changes
    if: |
      (github.event_name == 'workflow_dispatch' && inputs.run_terraform == true) ||
      (github.event_name != 'workflow_dispatch' && needs.detect-changes.outputs.infra_changed == 'true')
    outputs:
      plan_summary: ${{ steps.plan.outputs.plan_summary }}
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    env:
      # =======================================================================
      # Auth0 Terraform Service Account Credentials
      # =======================================================================
      # These credentials are for the TERRAFORM SERVICE ACCOUNT - a dedicated
      # M2M application that allows Terraform to manage Auth0 resources.
      #
      # IMPORTANT: These are NOT the credentials for the user-facing application.
      # When Terraform runs, it will CREATE a separate "yt-summarizer-api-bff"
      # application for end-user authentication. Those BFF credentials will be
      # different and must be stored in Azure Key Vault after Terraform completes.
      #
      # Service Account Details:
      #   - Application: "Terraform Service Account" (M2M)
      #   - Client ID: Fmh7q7q2OrqUvmSXTgBxr3E7v5KdAbt6
      #   - Purpose: Manage Auth0 resources via Terraform
      #   - Storage: GitHub Secrets (for CI/CD) + Azure Key Vault (for local runs)
      #
      # What Terraform Creates:
      #   - Auth0 Application: "yt-summarizer-api-bff" (for end users)
      #   - Auth0 API: "yt-summarizer-api" (resource server)
      #
      # Documentation: docs/auth0-terraform-service-account.md
      # =======================================================================
      AUTH0_DOMAIN: ${{ secrets.AUTH0_DOMAIN }}
      AUTH0_CLIENT_ID: ${{ secrets.AUTH0_CLIENT_ID }}
      AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_USE_OIDC: true
    defaults:
      run:
        working-directory: infra/terraform/environments/prod
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify Azure credentials are configured
        uses: ./.github/actions/verify-azure-credentials
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Terraform configuration
        uses: ./.github/actions/validate
        with:
          validators: terraform-config
          terraform-directory: infra/terraform/environments/prod
          fail-fast: 'true'
          timeout-seconds: '60'

      - name: Terraform Plan
        id: plan
        uses: ./.github/actions/terraform-plan
        with:
          working-directory: 'infra/terraform/environments/prod'
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          sql-admin-password: ${{ secrets.SQL_ADMIN_PASSWORD }}
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        continue-on-error: true

      - name: Post Plan to PR and Summary
        if: github.event_name == 'pull_request'
        uses: ./.github/actions/post-terraform-plan
        with:
          plan-summary: ${{ steps.plan.outputs.plan_summary }}
          formatted-plan: ${{ steps.plan.outputs.formatted_plan }}
          plan-outcome: ${{ steps.plan.outcome }}

      - name: Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      - name: Upload Terraform plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            infra/terraform/environments/prod/tfplan
            infra/terraform/environments/prod/plan_output.txt
            infra/terraform/environments/prod/plan.json

  # ===========================================================================
  # PHASE 1C: TERRAFORM APPLY
  # ===========================================================================
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: |
      needs.terraform-plan.result == 'success' &&
      fromJson(needs.terraform-plan.outputs.plan_summary).has_changes == true &&
      (github.event_name != 'workflow_dispatch' || inputs.apply_terraform == true)
    permissions:
      id-token: write
      contents: read
    env:
      AUTH0_DOMAIN: ${{ secrets.AUTH0_DOMAIN }}
      AUTH0_CLIENT_ID: ${{ secrets.AUTH0_CLIENT_ID }}
      AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_USE_OIDC: true
    defaults:
      run:
        working-directory: infra/terraform/environments/prod
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify Azure credentials are configured
        uses: ./.github/actions/verify-azure-credentials
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Download Terraform plan artifact
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/environments/prod

      - name: Validate Terraform configuration
        uses: ./.github/actions/validate
        with:
          validators: terraform-config
          terraform-directory: infra/terraform/environments/prod
          fail-fast: 'true'
          timeout-seconds: '60'

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan


  # ===========================================================================
  # PHASE 2: WAIT FOR CI COMPLETION
  # ===========================================================================
  # ONLY runs when needs_deployment=true
  # Waits for CI workflow to complete and retrieves image tag
  #
  # FLOW:
  #   1. Find CI workflow run for same commit SHA
  #   2. Wait up to 30min for completion
  #   3. Extract image tag from CI artifacts (pr-<number>-<sha>)
  #   4. Fail if CI fails (no fallback)
  #
  # CRITICAL: This enforces that CI must succeed before preview deploys
  # ===========================================================================
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.needs_deployment == 'true'
    outputs:
      image_tag: ${{ steps.wait.outputs.image_tag }}
      ci_run_id: ${{ steps.wait.outputs.ci_run_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for CI workflow to complete
        id: wait
        uses: ./.github/actions/wait-for-ci
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}
          timeout-seconds: '1800'

      - name: Azure Login
        if: steps.wait.outputs.image_tag != ''
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate image exists in ACR
        if: steps.wait.outputs.image_tag != ''
        uses: ./.github/actions/validate-acr-image
        with:
          registry: ${{ env.ACR_NAME }}
          repository: ${{ env.API_IMAGE_NAME }}
          tag: ${{ steps.wait.outputs.image_tag }}
          fail-if-missing: 'true'

  # ===========================================================================
  # PHASE 2B: FIND PR IMAGE TAG FOR K8S-ONLY CHANGES
  # ===========================================================================
  # For K8s-only changes (needs_image_build=false), we need a deterministic
  # image tag. Strategy:
  #   1. Walk backwards through PR's git history
  #   2. Find most recent commit that changed code (services/apps/docker)
  #   3. Use that commit's image tag: pr-<number>-<sha>
  #   4. If no commits in PR built images, fallback to production tag (read prod kustomization.yaml)
  #
  # This ensures K8s changes are tested with the PR's own code, not random
  # production code. Fully deterministic as it's tied to git history.
  # ===========================================================================
  get-production-tag:
    name: Find PR Image Tag
    runs-on: ubuntu-latest
    needs: [detect-changes, wait-for-ci]
    if: |
      needs.detect-changes.outputs.needs_deployment == 'true' &&
      (needs.detect-changes.outputs.needs_image_build == 'false' || github.event_name == 'workflow_dispatch')
    outputs:
      image_tag: ${{ steps.find-tag.outputs.image_tag }}
    steps:
      - name: Checkout PR branch with full history
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}
          fetch-depth: 0  # Need full history to walk commits

      - name: Find most recent image-building commit in PR
        id: find-tag
        shell: bash
        run: scripts/workflows/preview-find-pr-image-tag.sh

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate image exists in ACR
        uses: ./.github/actions/validate-acr-image
        with:
          registry: ${{ env.ACR_NAME }}
          repository: ${{ env.API_IMAGE_NAME }}
          tag: ${{ steps.find-tag.outputs.image_tag }}
          fail-if-missing: 'true'

  # ===========================================================================
  # PHASE 3: CONCURRENCY LIMIT CHECK
  # ===========================================================================
  # ONLY runs when both detect-changes and wait-for-ci succeed
  # Enforces MAX_PREVIEWS limit to prevent resource exhaustion
  #
  # FLOW:
  #   1. Count currently deployed previews
  #   2. If count < MAX_PREVIEWS ‚Üí can_deploy=true
  #   3. If count >= MAX_PREVIEWS ‚Üí can_deploy=false, post queue message
  #
  # Downstream jobs check can_deploy=true before running
  # ===========================================================================
  check-concurrency:
    name: Check Preview Limit
    runs-on: ubuntu-latest
    if: |
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      needs.detect-changes.result == 'success' &&
      needs.detect-changes.outputs.needs_deployment == 'true' &&
      needs.wait-for-ci.result == 'success' &&
      (needs.get-production-tag.result == 'success' || needs.get-production-tag.result == 'skipped')
    needs: [detect-changes, wait-for-ci, get-production-tag]
    outputs:
      can_deploy: ${{ steps.check.outputs.can_deploy }}
      final_image_tag: >-
        ${{ needs.wait-for-ci.outputs.image_tag != '' &&
            needs.wait-for-ci.outputs.image_tag ||
            needs.get-production-tag.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check preview concurrency limit
        id: check
        uses: ./.github/actions/check-preview-concurrency
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          max-previews: ${{ env.MAX_PREVIEWS }}

      - name: Post queue status
        if: steps.check.outputs.can_deploy == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const reasonLines = [
              `Maximum concurrent previews (${{ env.MAX_PREVIEWS }}) reached.`,
              'Your preview will deploy when a slot becomes available.',
              'Close another PR or wait for an existing preview to be cleaned up.'
            ];
            const reason = reasonLines.join('\n\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚è≥ **Preview Queued**\n\n${reason}`
            })

  # ===========================================================================
  # PHASE 4: COMPUTE PREVIEW URLS
  # ===========================================================================
  # ONLY runs when can_deploy=true
  # Generates preview URLs using Gateway API pattern
  #
  # URL PATTERN: pr-<number>.yt-summarizer.apps.ashleyhollis.com
  # Example: pr-42.yt-summarizer.apps.ashleyhollis.com
  #
  # Outputs:
  #   - preview_url: Full URL for API (https://pr-42.yt-summarizer...)
  #   - preview_host: Just hostname (pr-42.yt-summarizer...)
  #   - tls_secret: Secret name for TLS cert
  # ===========================================================================
  get-ingress:
    name: Prepare Preview URLs
    runs-on: ubuntu-latest
    if: |
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      needs.check-concurrency.result == 'success' &&
      needs.check-concurrency.outputs.can_deploy == 'true'
    needs: [check-concurrency, detect-changes]
    outputs:
      preview_url: ${{ steps.compute.outputs.preview-url }}
      preview_host: ${{ steps.compute.outputs.preview-host }}
      tls_secret: ${{ steps.compute.outputs.tls-secret }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Compute Preview URLs
        id: compute
        uses: ./.github/actions/compute-preview-urls
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          app-name: ${{ env.APP_NAME }}
          base-domain: ${{ env.APPS_BASE_DOMAIN }}

  # ===========================================================================
  # PHASE 5: UPDATE KUBERNETES OVERLAY
  # ===========================================================================
  # ONLY runs when can_deploy=true and get-ingress succeeds
  #
  # CRITICAL FLOW:
  #   1. Checkout PR branch (not main)
  #   2. Update k8s/overlays/preview/kustomization.yaml with:
  #      - Image tags from CI (pr-<number>-<sha>)
  #      - Preview hostname for ingress
  #      - TLS secret for certificate
  #   3. Validate kustomize build + kubectl dry-run
  #   4. Commit and push to PR branch
  #   5. Argo CD auto-detects commit and syncs to cluster
  #
  # WHY COMMIT TO PR BRANCH:
  #   - Argo CD watches PR branches for preview overlays
  #   - GitOps: Cluster state matches git (no out-of-band changes)
  #   - Reviewable: Preview config visible in PR diff
  # ===========================================================================
  update-overlay:
    name: Update Preview Overlay
    runs-on: ubuntu-latest
    if: |
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      needs.check-concurrency.result == 'success' &&
      needs.check-concurrency.outputs.can_deploy == 'true' &&
      needs.get-ingress.result == 'success' &&
      (needs.terraform-apply.result != 'failure')
    needs: [check-concurrency, wait-for-ci, get-ingress, detect-changes, terraform-apply]
    outputs:
      image_tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Kustomize
        uses: ./.github/actions/setup-kustomize
        with:
          install-python: 'true'

      - name: Azure ACR Login
        uses: ./.github/actions/azure-acr-login
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          acr-name: ${{ env.ACR_NAME }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Verify cluster can pull image
        # Runs after AKS context + ACR login are configured
        uses: ./.github/actions/validate-acr-image
        with:
          registry: ${{ env.ACR_NAME }}
          repository: ${{ env.API_IMAGE_NAME }}
          tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
          run-k8s-pull-test: 'true'

      - name: Validate CI image tag for PR
        if: needs.detect-changes.outputs.needs_image_build == 'true'
        uses: ./.github/actions/validate-image-tag
        with:
          ci-image-tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}

      - name: Update preview overlay with image tags
        id: overlay
        uses: ./.github/actions/update-preview-overlay
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          image-tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
          acr-server: ${{ env.ACR_LOGIN_SERVER }}
          preview-host: ${{ needs.get-ingress.outputs.preview_host }}
          tls-secret: ${{ needs.get-ingress.outputs.tls_secret }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}

      - name: Validate generated overlay (kustomize + dry-run)
        uses: ./.github/actions/validate
        with:
          validators: kustomize-build
          overlay-paths: ${{ env.KUSTOMIZE_OVERLAY_PREVIEW }}
          fail-fast: 'true'
          timeout-seconds: '30'

      - name: Commit and push overlay update
        uses: ./.github/actions/commit-overlay-changes
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          image-tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}
          pr-branch: ${{ needs.detect-changes.outputs.pr_head_ref || github.ref_name }}

  # ===========================================================================
  # PHASE 6: VERIFY DEPLOYMENT
  # ===========================================================================
  # ONLY runs when update-overlay succeeds
  #
  # VERIFICATION STEPS:
  #   1. Wait for Argo CD to sync (detects overlay commit)
  #   2. Verify API deployment has correct image tag
  #   3. Verify worker deployments have correct image tag
  #   4. Run health checks against preview URL
  #   5. Verify TLS certificate is valid
  #
  # FAILURE SCENARIOS:
  #   - Argo CD sync timeout ‚Üí likely image pull failure
  #   - Wrong image tag ‚Üí overlay update didn't propagate
  #   - Health check fails ‚Üí application startup error
  #   - TLS check fails ‚Üí certificate provisioning issue
  # ===========================================================================
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    if: |
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      needs.check-concurrency.result == 'success' &&
      needs.check-concurrency.outputs.can_deploy == 'true' &&
      needs.update-overlay.result == 'success'
    needs: [update-overlay, check-concurrency, wait-for-ci, get-ingress, detect-changes]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Setup Kustomize
        uses: ./.github/actions/setup-kustomize
        with:
          kustomize-version: '5.8.0'

      - name: Cleanup stuck Argo CD operations
        uses: ./.github/actions/cleanup-argocd-operation
        with:
          app-name: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          namespace: argocd
          timeout-threshold: '300'
        continue-on-error: false

      - name: Pre-deployment validation
        uses: ./.github/actions/validate
        with:
          validators: kustomize-build,argocd-manifest
          overlay-paths: ${{ env.KUSTOMIZE_OVERLAY_PREVIEW }}
          argocd-app-name: ${{ env.PREVIEW_NAMESPACE_PREFIX }}${{ needs.detect-changes.outputs.pr_number }}
          argocd-namespace: ${{ env.NAMESPACE_ARGOCD }}
          target-namespace: ${{ env.PREVIEW_NAMESPACE_PREFIX }}${{ needs.detect-changes.outputs.pr_number }}
          timeout-seconds: '60'

      - name: Check Argo CD application readiness
        uses: ./.github/actions/check-argocd-readiness
        with:
          app-name: ${{ env.PREVIEW_NAMESPACE_PREFIX }}${{ needs.detect-changes.outputs.pr_number }}
          namespace: ${{ env.NAMESPACE_ARGOCD }}
          timeout: '60'

      - name: Wait for Argo CD to sync
        uses: ./.github/actions/wait-for-argocd
        with:
          app-name: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          timeout-seconds: '180'

      - name: Verify API deployment image
        uses: ./.github/actions/verify-deployment
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          deployment-name: api
          expected-tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
          registry: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
          image-name: ${{ env.API_IMAGE_NAME }}

      - name: Verify workers deployment image
        uses: ./.github/actions/verify-workers
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          expected-tag: ${{ needs.check-concurrency.outputs.final_image_tag }}
          registry: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
          image-name: ${{ env.WORKERS_IMAGE_NAME }}
          workers: ${{ env.WORKER_DEPLOYMENTS }}
          fail-on-mismatch: 'true'

      - name: Collect deployment diagnostics on failure
        if: failure()
        shell: bash
        run: |
          ./scripts/diagnose-argocd-deployment.sh \
            ${{ env.PREVIEW_NAMESPACE_PREFIX }}${{ needs.detect-changes.outputs.pr_number }} \
            ./diagnostics

      - name: Upload diagnostics artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-diagnostics-pr-${{ needs.detect-changes.outputs.pr_number }}
          path: diagnostics/
          retention-days: 7

      - name: Run API health checks
        if: needs.get-ingress.outputs.preview_url != ''
        uses: ./.github/actions/health-check-preview
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          external-url: ${{ needs.get-ingress.outputs.preview_url }}
          max-attempts: '10'
          interval-seconds: '10'

      - name: Verify API Certificate
        uses: ./.github/actions/verify-certificate
        with:
          host: ${{ needs.get-ingress.outputs.preview_host }}

  # ===========================================================================
  # PHASE 7: DEPLOY FRONTEND (PARALLEL with verify-deployment)
  # ===========================================================================
  # ONLY runs when can_deploy=true and get-ingress succeeds
  # Runs in parallel with verify-deployment (no dependency)
  #
  # FLOW:
  #   1. Build Next.js app with preview API URL
  #   2. Cleanup stale SWA environments (old closed PRs)
  #   3. Deploy to Azure Static Web Apps
  #   4. SWA creates ephemeral preview environment
  #
  # SWA CLEANUP:
  #   - Runs before deploy to free up slots
  #   - Deletes environments for closed/merged PRs
  #   - Min age: 1 hour (prevents accidental deletions)
  # ===========================================================================
  deploy-frontend-preview:
    name: Deploy Frontend Preview
    runs-on: ubuntu-latest
    if: |
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      needs.check-concurrency.result == 'success' &&
      needs.check-concurrency.outputs.can_deploy == 'true' &&
      needs.get-ingress.result == 'success'
    needs: [get-ingress, detect-changes, check-concurrency, wait-for-ci]
    outputs:
      frontend_preview_url: ${{ steps.deploy.outputs.static_web_app_url }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}

      - name: Verify SWA token is configured
        uses: ./.github/actions/verify-secret
        with:
          secret-name: 'SWA_DEPLOYMENT_TOKEN'
          secret-value: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}

      - name: Download frontend build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: /tmp/frontend-build
          run-id: ${{ needs.wait-for-ci.outputs.ci_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Replace apps/web with CI build
        shell: bash
        run: |
          if [[ -d /tmp/frontend-build/apps/web ]]; then
            source_dir="/tmp/frontend-build/apps/web"
          else
            source_dir="/tmp/frontend-build"
          fi
          if [[ ! -d "$source_dir" ]]; then
            echo "::error::Expected CI build directory not found at $source_dir"
            ls -la /tmp/frontend-build || true
            exit 1
          fi
          # Remove the source code version of apps/web
          rm -rf apps/web
          # Move the CI build to apps/web
          mv "$source_dir" apps/web
          # Verify the structure
          echo "=== apps/web structure ==="
          ls -la apps/web/
          echo "=== apps/web/.next structure ==="
          ls -la apps/web/.next/ || echo "No .next directory"

      - name: Write runtime config
        shell: bash
        run: |
          bash scripts/workflows/write-runtime-config.sh \
            "apps/web/public/runtime-config.js" \
            "${{ needs.get-ingress.outputs.preview_url }}"

      - name: Azure Login for SWA cleanup
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Cleanup stale SWA environments
        id: cleanup-stale
        continue-on-error: true
        uses: ./.github/actions/cleanup-stale-swa-environments
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          swa-name: ${{ vars.SWA_NAME || 'swa-ytsumm-prd' }}
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          dry-run: 'false'
          min-age-hours: '1'
          max-prs-to-check: '50'

      - name: Report cleanup results
        if: steps.cleanup-stale.outputs.deleted-count != '0'
        run: |
          echo "‚úÖ Cleaned up ${{ steps.cleanup-stale.outputs.deleted-count }} stale SWA environment(s)"
          echo "üí° Deleted environments for PRs: ${{ steps.cleanup-stale.outputs.stale-prs }}"

      - name: Deploy to SWA staging environment
        id: deploy
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}

          action: upload
          # For Next.js hybrid, app_location is the Next.js app root
          app_location: apps/web
          # For Next.js hybrid, output_location MUST be empty
          # SWA handles the .next folder internally
          output_location: ""
          skip_app_build: true
          # Deploying to a PR creates a staging environment automatically
          production_branch: main

      - name: Verify frontend preview
        if: steps.deploy.outputs.static_web_app_url != ''
        uses: ./.github/actions/health-check
        with:
          url: ${{ steps.deploy.outputs.static_web_app_url }}
          max-attempts: '10'
          interval-seconds: '10'
          timeout-seconds: '5'
          expected-status: '200'
          service-name: 'Preview Web'

  # ===========================================================================
  # PHASE 8: POST PREVIEW COMMENT
  # ===========================================================================
  # ONLY runs when BOTH verify-deployment AND deploy-frontend succeed
  # Posts comment to PR with:
  #   - Backend API URL
  #   - Frontend SWA URL
  #   - Image tag used
  #   - Commit SHA
  # ===========================================================================
  post-preview-comment:
    name: Post Preview Comment
    runs-on: ubuntu-latest
    if: >-
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      needs.check-concurrency.result == 'success' &&
      needs.check-concurrency.outputs.can_deploy == 'true' &&
      needs.verify-deployment.result == 'success' &&
      needs.deploy-frontend-preview.result == 'success'
    needs:
      - update-overlay
      - verify-deployment
      - deploy-frontend-preview
      - detect-changes
      - get-ingress
      - check-concurrency
      - wait-for-ci
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Post preview URL to PR
        uses: ./.github/actions/post-preview-comment
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          image-tag: ${{ needs.wait-for-ci.outputs.image_tag }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}
          frontend-url: ${{ needs.deploy-frontend-preview.outputs.frontend_preview_url }}
          run-id: ${{ github.run_id }}
          repository: ${{ github.repository }}

      - name: Create deployment summary
        uses: ./.github/actions/create-preview-summary
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          image-tag: ${{ needs.wait-for-ci.outputs.image_tag }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}

  # ===========================================================================
  # PHASE 9: E2E TESTS (OPTIONAL)
  # ===========================================================================
  # ONLY runs when post-preview-comment succeeds AND preview_url is set
  #
  # FLOW:
  #   1. Wait for Argo CD sync (double-check deployment ready)
  #   2. Wait for API health check (ensure startup complete)
  #   3. Run Playwright E2E tests against preview environment
  #   4. Upload test report artifact
  #   5. Post results to PR
  #
  # TEST ENVIRONMENT:
  #   - Frontend: SWA preview URL
  #   - Backend: Gateway API preview URL
  #   - Full integration test of real environment
  # ===========================================================================
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs:
      - update-overlay
      - verify-deployment
      - deploy-frontend-preview
      - post-preview-comment
      - detect-changes
      - get-ingress
      - check-concurrency
    if: >-
      always() && !cancelled() &&
      (github.event_name != 'workflow_dispatch' || inputs.run_preview == true) &&
      (github.event_name != 'workflow_dispatch' || inputs.run_e2e == true) &&
      needs.check-concurrency.result == 'success' &&
      needs.check-concurrency.outputs.can_deploy == 'true' &&
      needs.post-preview-comment.result == 'success' &&
      needs.get-ingress.outputs.preview_url != ''
    outputs:
      result: ${{ steps.run-tests.outcome }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: '22'
          working-directory: apps/web

      # No need to wait for Argo CD sync again - verify-deployment job already did this
      # and this job depends on verify-deployment, so we know the sync completed successfully

      - name: Wait for API to be ready
        uses: ./.github/actions/health-check
        with:
          url: ${{ needs.get-ingress.outputs.preview_url }}/health/live
          max-attempts: '20'
          interval-seconds: '15'
          timeout-seconds: '5'
          expected-status: '200'
          service-name: 'Preview API (E2E)'

      - name: Run E2E tests
        id: base-url
        shell: bash
        run: |
          base_url="${{ needs.deploy-frontend-preview.outputs.frontend_preview_url }}"
          if [[ -z "$base_url" ]]; then
            base_url="${{ needs.get-ingress.outputs.preview_url }}"
          fi
          echo "base_url=$base_url" >> "$GITHUB_OUTPUT"

      - name: Run E2E tests
        id: run-tests
        uses: ./.github/actions/run-playwright-tests
        env:
          USE_EXTERNAL_SERVER: "true"
          BASE_URL: ${{ steps.base-url.outputs.base_url }}
          NEXT_PUBLIC_API_URL: ${{ needs.get-ingress.outputs.preview_url }}
          API_URL: ${{ needs.get-ingress.outputs.preview_url }}

      - name: Upload Playwright report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report-pr-${{ needs.detect-changes.outputs.pr_number }}
          path: apps/web/playwright-report/
          retention-days: 7

      - name: Comment E2E results on PR
        if: always()
        uses: ./.github/actions/post-e2e-results
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          test-outcome: ${{ steps.run-tests.outcome }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}
          run-id: ${{ github.run_id }}
          repository: ${{ github.repository }}

  # ===========================================================================
  # PHASE 10: FINAL STATUS CHECK
  # ===========================================================================
  # always() ensures this runs regardless of job results
  #
  # VALIDATES:
  #   1. If deployment needed, did all steps succeed?
  #   2. If no deployment needed, did workflow skip appropriately?
  #   3. Are all URLs configured correctly?
  #
  # FAIL CONDITIONS:
  #   - needs_deployment=true but verify-deployment failed
  #   - needs_deployment=true but deploy-frontend failed
  #   - preview_url missing when deployment succeeded
  #
  # This is the required status check for PR merging
  # ===========================================================================
  preview-status-check:
    name: Preview Status Check
    runs-on: ubuntu-latest
    needs:
      - detect-changes
      - wait-for-ci
      - update-overlay
      - verify-deployment
      - deploy-frontend-preview
      - e2e-tests
      - get-ingress
      - terraform-plan
      - terraform-apply
      - check-concurrency
    if: always()
    steps:

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Write execution rationale
        env:
          PLAN_SUMMARY: ${{ needs.terraform-plan.outputs.plan_summary }}
        run: |
          {
            echo "## Preview Execution Rationale"
            echo ""
            echo "- Needs deployment: ${{ needs.detect-changes.outputs.needs_deployment }}"
            echo "- Needs image build: ${{ needs.detect-changes.outputs.needs_image_build }}"
            echo "- Infra changed: ${{ needs.detect-changes.outputs.infra_changed }}"
            terraform_plan_changes="n/a"
            if [[ -n "$PLAN_SUMMARY" ]]; then
              terraform_plan_changes="$PLAN_SUMMARY"
            fi
            terraform_plan_reason="not requested"
            if [[ "${{ github.event_name }}" == 'workflow_dispatch' && "${{ inputs.run_terraform }}" == 'true' ]]; then
              terraform_plan_reason="manual request"
            elif [[ "${{ needs.detect-changes.outputs.infra_changed }}" == 'true' ]]; then
              terraform_plan_reason="infra changes"
            fi
            wait_reason="no deployment"
            if [[ "${{ needs.detect-changes.outputs.needs_deployment }}" == 'true' ]]; then
              wait_reason="deployment needed"
            fi
            echo "- Terraform plan: ${{ needs.terraform-plan.result }}"
            echo "  changes: ${terraform_plan_changes}"
            echo "  reason: ${terraform_plan_reason}"
            echo "- Terraform apply: ${{ needs.terraform-apply.result }}"
            echo "- Wait for CI: ${{ needs.wait-for-ci.result }}"
            echo "  reason: ${wait_reason}"
            echo "- Concurrency gate: ${{ needs.check-concurrency.outputs.can_deploy || 'n/a' }}"
            echo "- Overlay update: ${{ needs.update-overlay.result }}"
            echo "- Backend verify: ${{ needs.verify-deployment.result }}"
            echo "- Frontend deploy: ${{ needs.deploy-frontend-preview.result }}"
            echo "- E2E tests: ${{ needs.e2e-tests.result }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Check preview pipeline status
        uses: ./.github/actions/check-preview-status
        with:
          needs-image-build: ${{ needs.detect-changes.outputs.needs_image_build }}
          needs-deployment: ${{ needs.detect-changes.outputs.needs_deployment }}
          wait-for-ci-result: ${{ needs.wait-for-ci.result }}
          update-overlay-result: ${{ needs.update-overlay.result }}
          verify-deployment-result: ${{ needs.verify-deployment.result }}
          deploy-frontend-result: ${{ needs.deploy-frontend-preview.result }}
          e2e-tests-result: ${{ needs.e2e-tests.result }}
          api-url-configured: ${{ needs.get-ingress.outputs.preview_url }}
