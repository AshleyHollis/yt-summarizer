# =============================================================================
# Preview Workflow - Deploy PR Preview Environment
# =============================================================================
# Deploys preview environment using images already built by CI workflow
# Argo CD ApplicationSet with Pull Request Generator picks up the changes
# Runs E2E tests after deployment to validate changes
#
# IMPORTANT: Uses pull_request trigger instead of workflow_run due to GitHub limitation
# See: https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#workflow_run
# Force deploy comment
#
# WORKFLOW_RUN LIMITATION: workflow_run triggers ONLY work if the workflow file exists on the default branch (main).
# This creates a chicken-and-egg problem: you can't test workflow_run triggers before merging to main.
# Therefore, we use pull_request trigger with wait-for-ci logic instead.
#
# TRIGGER CHOICE: pull_request ensures the workflow runs from feature branches and waits for CI completion.
# This is the industry-standard pattern for PR-based preview deployments.
#
# =============================================================================
# CI/PREVIEW RELATIONSHIP & IMAGE TAG HANDLING
# =============================================================================
# ROOT CAUSE (FIXED): Preview workflow was running for ANY code changes, but CI only builds
# images for specific areas (services/api, services/workers, services/shared, apps/web, docker).
# When PRs changed other files (like CI workflows), preview would run but fail because no
# image tag artifact was created by CI.
#
# SOLUTION: detect-pr-code-changes now only returns true for changes that actually trigger
# image building in CI. This ensures preview only runs when images are available.
#
# WORKFLOW SEQUENCE:
# 1. detect-changes: Check if PR contains changes that would build images
# 2. wait-for-ci: Wait for CI completion and retrieve image_tag from artifact
# 3. check-concurrency: Validate image_tag exists + check preview limits
# 4. update-overlay: Generate Kustomize overlay with PR-specific image tags
# 5. deploy: ArgoCD picks up overlay changes and deploys
# 6. verify-deployment: Ensure pods are running correct images
# 7. e2e: Run end-to-end tests against preview environment

name: Preview Deployment

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  # Allow manual triggering for testing from any branch
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to deploy preview for (optional - will use latest commit)'
        required: false
        type: string
      force_deploy:
        description: 'Force deployment even without code changes'
        required: false
        type: boolean
        default: false

concurrency:
  group: preview-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true


env:
  # PR_NUMBER: Critical for workflow_run compatibility - extracts PR number from either
  # pull_request events (github.event.pull_request.number) or workflow_run events
  # (github.event.workflow_run.pull_requests[0].number). Used throughout workflow
  # to avoid repeating this complex expression 15+ times.
  # PR metadata is emitted by the detect-changes job to avoid top-level context evaluation warnings
  ACR_NAME: ${{ vars.ACR_NAME || 'acrytsummprd' }}
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
  MAX_PREVIEWS: 3

permissions:
  id-token: write
  contents: write
  pull-requests: write
  checks: write

jobs:
  # ---------------------------------------------------------------------------
  # Detect Changes (commit-level check for docs-only changes)
  # ---------------------------------------------------------------------------
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    outputs:
      needs_image_build: ${{ steps.check.outputs.needs_image_build }}
      needs_deployment: ${{ steps.check.outputs.needs_deployment }}
      pr_number: ${{ steps.set-pr.outputs.pr_number }}
      pr_head_ref: ${{ steps.set-pr.outputs.pr_head_ref }}
      pr_head_sha: ${{ steps.set-pr.outputs.pr_head_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git diff

      - name: Set PR metadata
        id: set-pr
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "pr_head_ref=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
            echo "pr_head_sha=${{ github.event.pull_request.head.sha }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PR_NUM="${{ github.event.inputs.pr_number }}"
            if [ -n "$PR_NUM" ]; then
              echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
              echo "pr_head_ref=${{ github.ref_name }}" >> $GITHUB_OUTPUT
              echo "pr_head_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            else
              # No PR specified, use current commit
              echo "pr_number=" >> $GITHUB_OUTPUT
              echo "pr_head_ref=${{ github.ref_name }}" >> $GITHUB_OUTPUT
              echo "pr_head_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Set base SHA for comparison
        id: base-sha
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "base_sha=${{ github.event.pull_request.base.sha }}" >> $GITHUB_OUTPUT
          else
            echo "base_sha=origin/main" >> $GITHUB_OUTPUT
          fi

      - name: Check if commit has code changes
        id: check
        uses: ./.github/actions/detect-pr-code-changes
        with:
          base-sha: ${{ steps.base-sha.outputs.base_sha }}
          head-sha: ${{ steps.set-pr.outputs.pr_head_sha }}
          pr-number: ${{ steps.set-pr.outputs.pr_number }}
          force-deploy: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_deploy }}


  # ---------------------------------------------------------------------------
  # Wait for CI to Pass
  # ---------------------------------------------------------------------------
  # Ensures CI workflow completes successfully before proceeding with preview deployment.
  # This prevents deploying with broken code and ensures images are built and available.
  #
  # WHY THIS PATTERN: We use pull_request trigger + wait-for-ci instead of workflow_run
  # because workflow_run requires the workflow file to exist on the default branch first,
  # creating a testing paradox for new features.
  # ---------------------------------------------------------------------------
  # Wait for CI (30-minute timeout prevents infinite waiting on stuck CI jobs)
  # ---------------------------------------------------------------------------
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    needs: detect-changes
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.detect-changes.outputs.needs_image_build == 'true'
    outputs:
      image_tag: ${{ steps.wait.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # NOTE: workflow_run logic kept for future reference but not currently used
      # due to GitHub's requirement that workflow_run triggers only work from default branch
      - name: Verify CI workflow passed (workflow_run trigger - NOT USED)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: ./.github/actions/verify-ci-workflow
        with:
          workflow-conclusion: ${{ github.event.workflow_run.conclusion }}
          workflow-name: ${{ github.event.workflow_run.name }}

      - name: Wait for CI workflow to complete
        # Wait for CI: Polls GitHub API for CI workflow status, ensuring preview only deploys
        # after successful CI completion. EXITS EARLY on CI failure/cancellation to avoid
        # wasting CPU cycles. Uses 30-minute timeout to prevent infinite waiting on stuck CI.
        # Only runs on pull_request events (workflow_run events would use different logic).
        if: ${{ github.event_name == 'pull_request' }}
        uses: ./.github/actions/wait-for-ci
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}
          timeout-seconds: '1800'  # 30 minutes timeout

      # Image tag is provided by CI via artifact and validated by `validate-image-tag`. No local generation here.

  # ---------------------------------------------------------------------------  
  # Get Existing Image Tag (for K8s-only changes)
  # ---------------------------------------------------------------------------
  get-existing-image-tag:
    name: Get Existing Image Tag
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.needs_deployment == 'true' && needs.detect-changes.outputs.needs_image_build == 'false'
    outputs:
      image_tag: ${{ steps.get-tag.outputs.image_tag }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          sparse-checkout: k8s/overlays/prod

      - name: Extract current image tag from production overlay
        id: get-tag
        run: |
          # Get the current image tag from the production kustomization
          IMAGE_TAG=$(grep -oP 'newTag: \K.*' k8s/overlays/prod/kustomization.yaml | head -1)
          if [ -z "$IMAGE_TAG" ]; then
            echo "::error::Could not find image tag in production overlay"
            exit 1
          fi
          echo "Found existing image tag: $IMAGE_TAG"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  # ---------------------------------------------------------------------------  
  # Build Images for Manual Triggers (workflow_dispatch)
  # ---------------------------------------------------------------------------
  build-images-manual:
    name: Build Images (Manual - parallel)
    runs-on: ubuntu-latest
    needs: detect-changes
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.force_deploy == 'true'
    strategy:
      matrix:
        include:
          - service: api
            dockerfile: services/api/Dockerfile
            image: yt-summarizer-api
          - service: workers
            dockerfile: services/workers/Dockerfile
            image: yt-summarizer-workers
    outputs:
      image_tag: ${{ steps.tag.outputs.image-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image tag
        id: tag
        uses: ./.github/actions/generate-image-tag
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}

      - name: Login to Azure Container Registry
        uses: ./.github/actions/azure-acr-login
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          acr-name: ${{ env.ACR_NAME }}

      - name: Build and push ${{ matrix.service }} image
        uses: ./.github/actions/build-images
        with:
          service: ${{ matrix.service }}
          image-tag: ${{ steps.tag.outputs.image-tag }}
          push: true

      - name: Publish image tag artifact
        if: matrix.service == 'api'
        uses: ./.github/actions/publish-image-tag
        with:
          image-tag: ${{ steps.tag.outputs.image-tag }}

  # ---------------------------------------------------------------------------
  # Check Active Preview Count (prevents resource exhaustion from too many previews)
  # ---------------------------------------------------------------------------
  check-concurrency:
    name: Check Preview Limit
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.detect-changes.outputs.needs_deployment == 'true'
    needs: 
      - detect-changes
      - wait-for-ci
    outputs:
      can_deploy: ${{ steps.validate-tag.outputs.can_deploy }}
      image_tag: ${{ steps.export-image.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check preview concurrency limit
        id: check
        uses: ./.github/actions/check-preview-concurrency
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          max-previews: ${{ env.MAX_PREVIEWS }}

      - name: Determine final image tag
        id: determine-tag
        run: |
          # Determine image tag based on which jobs actually ran and provided outputs
          IMAGE_TAG=""
          
          # Priority order: CI build > manual build > existing tag
          if [ -n "${{ needs.wait-for-ci.outputs.image_tag }}" ]; then
            IMAGE_TAG="${{ needs.wait-for-ci.outputs.image_tag }}"
            echo "Using image tag from CI: $IMAGE_TAG"
          elif [ -n "${{ needs.build-images-manual.outputs.image_tag }}" ]; then
            IMAGE_TAG="${{ needs.build-images-manual.outputs.image_tag }}"
            echo "Using image tag from manual build: $IMAGE_TAG"
          elif [ -n "${{ needs.get-existing-image-tag.outputs.image_tag }}" ]; then
            IMAGE_TAG="${{ needs.get-existing-image-tag.outputs.image_tag }}"
            echo "Using existing image tag: $IMAGE_TAG"
          fi
          
          if [ -z "$IMAGE_TAG" ]; then
            echo "::error::No image tag available for deployment"
            echo "Debug info:"
            echo "  needs_image_build: ${{ needs.detect-changes.outputs.needs_image_build }}"
            echo "  wait-for-ci image_tag: ${{ needs.wait-for-ci.outputs.image_tag }}"
            echo "  build-images-manual image_tag: ${{ needs.build-images-manual.outputs.image_tag }}"
            echo "  get-existing-image-tag image_tag: ${{ needs.get-existing-image-tag.outputs.image_tag }}"
            exit 1
          fi
          
          echo "Final image tag: $IMAGE_TAG"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Validate image tag is available
        id: validate-tag
        uses: ./.github/actions/validate-image-tag-availability
        with:
          image_tag: ${{ steps.determine-tag.outputs.image_tag }}
          concurrency_check_result: ${{ steps.check.outputs.can_deploy }}

      - name: Export computed image tag
        id: export-image
        uses: ./.github/actions/export-image-tag
        with:
          image-tag: ${{ steps.determine-tag.outputs.image_tag }}


      - name: Post queue status
        if: steps.validate-tag.outputs.can_deploy == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const reason = "${{ needs.wait-for-ci.outputs.image_tag || needs.get-existing-image-tag.outputs.image_tag || needs.build-images-manual.outputs.image_tag }}" === "" 
              ? "No image tag available from CI. This may indicate CI did not build images for this PR."
              : `Maximum concurrent previews (${{ env.MAX_PREVIEWS }}) reached. Your preview will deploy when a slot becomes available.\n\nClose another PR or wait for an existing preview to be cleaned up.`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚è≥ **Preview ${reason.includes("image tag") ? "Skipped" : "Queued"}**\n\n${reason}`
            })

  # ---------------------------------------------------------------------------
  # Get Ingress Info (retrieves cluster ingress IP for preview URL computation)
  # ---------------------------------------------------------------------------
  get-ingress:
    name: Get Ingress Info
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.check-concurrency.outputs.can_deploy == 'true'
    needs: [check-concurrency, detect-changes]
    outputs:
      ingress_ip: ${{ steps.get-ip.outputs.ingress-ip }}
      preview_url: ${{ steps.compute.outputs.preview-url }}
      preview_host: ${{ steps.compute.outputs.preview-host }}
      tls_secret: ${{ steps.compute.outputs.tls-secret }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get Ingress Controller IP
        id: get-ip
        uses: ./.github/actions/get-aks-ingress-ip
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Compute Preview URLs
        id: compute
        uses: ./.github/actions/compute-preview-urls
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          ingress-ip: ${{ steps.get-ip.outputs.ingress-ip }}

  # ---------------------------------------------------------------------------
  # Update Preview Overlay (modifies Kustomize overlay with PR-specific image tags and URLs)
  # ---------------------------------------------------------------------------
  update-overlay:
    name: Update Preview Overlay
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.check-concurrency.outputs.can_deploy == 'true'
    needs: [check-concurrency, get-ingress, detect-changes]
    outputs:
      image_tag: ${{ needs.check-concurrency.outputs.image_tag }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr_head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python with dependencies
        uses: ./.github/actions/setup-kustomize
        with:
          install-python: 'true'

      - name: Azure ACR Login
        uses: ./.github/actions/azure-acr-login
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          acr-name: ${{ env.ACR_NAME }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AZURE_AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Get Ingress Controller IP
        id: ingress-ip
        uses: ./.github/actions/get-aks-ingress-ip
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AZURE_AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}


      - name: Validate CI image tag for PR
        uses: ./.github/actions/validate-image-tag
        with:
          ci-image-tag: ${{ needs.check-concurrency.outputs.image_tag }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}

      - name: Update preview overlay with image tags
        id: overlay
        uses: ./.github/actions/update-preview-overlay
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          image-tag: ${{ needs.check-concurrency.outputs.image_tag }}
          acr-server: ${{ env.ACR_LOGIN_SERVER }}
          preview-host: ${{ needs.get-ingress.outputs.preview_host }}
          tls-secret: ${{ needs.get-ingress.outputs.tls_secret }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha || github.sha }}

      - name: Validate generated overlay (kustomize + dry-run)
        uses: ./.github/actions/kustomize-validate
        with:
          overlay-path: k8s/overlays/preview
          overlay-name: preview

      - name: Commit and push overlay update
        uses: ./.github/actions/commit-overlay-changes
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          image-tag: ${{ needs.check-concurrency.outputs.image_tag }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}
          pr-branch: ${{ needs.detect-changes.outputs.pr_head_ref }}

  # ---------------------------------------------------------------------------
  # Verify Deployment
  # ---------------------------------------------------------------------------
  # Waits for Argo CD to sync and verifies pods are running the correct images
  # ---------------------------------------------------------------------------
  # Verify Deployment (ensures preview environment is healthy and using correct images)
  # ---------------------------------------------------------------------------
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.check-concurrency.outputs.can_deploy == 'true'
    needs: [update-overlay, check-concurrency]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Wait for Argo CD to sync
        uses: ./.github/actions/wait-for-argocd-sync
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          timeout-seconds: '180'

      - name: Verify API deployment image
        uses: ./.github/actions/verify-deployment-image
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          deployment-name: api
          expected-tag: ${{ needs.check-concurrency.outputs.image_tag }}
      - name: Verify workers deployment image
        uses: ./.github/actions/verify-worker-deployments
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          expected-tag: ${{ needs.check-concurrency.outputs.image_tag }}
          registry: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
          workers: 'transcribe-worker,summarize-worker,embed-worker,relationships-worker'
          fail-on-mismatch: 'false'


      - name: Run basic API health check
        if: needs.update-overlay.outputs.preview_url != ''
        uses: ./.github/actions/health-check
        with:
          url: ${{ needs.update-overlay.outputs.preview_url }}/health/live
          max-attempts: '10'
          interval-seconds: '10'
          timeout-seconds: '5'
          expected-status: '200'
          service-name: 'Preview API'

      - name: Verify API Certificate
        uses: ./.github/actions/verify-tls-certificate
        with:
          host: ${{ needs.get-ingress.outputs.preview_host }}

  # ---------------------------------------------------------------------------
  # Deploy Frontend Preview to SWA (Static Web App for fast frontend previews)
  # ---------------------------------------------------------------------------
  deploy-frontend-preview:
    name: Deploy Frontend Preview
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.check-concurrency.outputs.can_deploy == 'true'
    needs: [get-ingress, detect-changes]
    outputs:
      frontend_preview_url: ${{ steps.deploy.outputs.static_web_app_url }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-changes.outputs.pr_head_ref }}

      - name: Verify SWA token is configured
        uses: ./.github/actions/verify-secret
        with:
          secret-name: 'SWA_DEPLOYMENT_TOKEN'
          secret-value: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: "20"
          working-directory: apps/web

      - name: Build frontend for preview
        uses: ./.github/actions/build-frontend
        with:
          api-url: ${{ needs.get-ingress.outputs.preview_url }}
          environment: 'preview'
          working-directory: 'apps/web'

      - name: Deploy to SWA staging environment
        id: deploy
        uses: Azure/static-web-apps-deploy@v1
        env:
          # Set the backend API URL for runtime
          NEXT_PUBLIC_API_URL: ${{ needs.get-ingress.outputs.preview_url || '' }}
          NEXT_PUBLIC_ENVIRONMENT: preview
        with:
          azure_static_web_apps_api_token: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}

          action: upload
          # For Next.js hybrid, app_location is the Next.js app root
          app_location: apps/web
          # For Next.js hybrid, output_location MUST be empty
          # SWA handles the .next folder internally
          output_location: ""
          skip_app_build: true
          # Deploying to a PR creates a staging environment automatically
          production_branch: main

  # ---------------------------------------------------------------------------
  # Post Preview Comment
  # ---------------------------------------------------------------------------
  # Posts preview information to the PR for reviewers (human-facing).
  # This is intentionally separate from the preview status check to avoid
  # blocking merges if posting a comment fails.
  post-preview-comment:
    name: Post Preview Comment
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.check-concurrency.outputs.can_deploy == 'true'
    needs: [update-overlay, verify-deployment, deploy-frontend-preview, detect-changes]
    steps:
      - name: Post preview URL to PR
        uses: ./.github/actions/post-preview-comment
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          image-tag: ${{ needs.check-concurrency.outputs.image_tag }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}
          frontend-url: ${{ needs.deploy-frontend-preview.outputs.frontend_preview_url }}

      - name: Create deployment summary
        uses: ./.github/actions/create-preview-summary
        with:
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          image-tag: ${{ needs.check-concurrency.outputs.image_tag }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}


  # ---------------------------------------------------------------------------
  # E2E Tests on Preview Environment (validates complete user journey in deployed preview)
  # ---------------------------------------------------------------------------
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [update-overlay, verify-deployment, deploy-frontend-preview, post-preview-comment, detect-changes]
    # Skip E2E tests if no API URL is configured or not a PR/workflow_dispatch event
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && needs.check-concurrency.outputs.can_deploy == 'true' && needs.get-ingress.outputs.preview_url != ''
    outputs:
      result: ${{ steps.run-tests.outcome }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: 'npm'
          cache-dependency-path: apps/web/package-lock.json

      - name: Install dependencies
        working-directory: apps/web
        run: npm ci

      - name: Wait for ArgoCD sync
        uses: ./.github/actions/wait-for-argocd-sync
        with:
          namespace: preview-pr-${{ needs.detect-changes.outputs.pr_number }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          timeout-seconds: '60'

      - name: Wait for API to be ready
        uses: ./.github/actions/health-check
        with:
          url: ${{ needs.get-ingress.outputs.preview_url }}/health/live
          max-attempts: '20'
          interval-seconds: '15'
          timeout-seconds: '5'
          expected-status: '200'
          service-name: 'Preview API (E2E)'

      - name: Run E2E tests
        id: run-tests
        uses: ./.github/actions/run-playwright-tests
        env:
          USE_EXTERNAL_SERVER: "true"
          BASE_URL: ${{ needs.deploy-frontend-preview.outputs.frontend_preview_url || needs.get-ingress.outputs.preview_url }}
          NEXT_PUBLIC_API_URL: ${{ needs.get-ingress.outputs.preview_url }}
          API_URL: ${{ needs.get-ingress.outputs.preview_url }}

      - name: Upload Playwright report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report-pr-${{ needs.detect-changes.outputs.pr_number }}
          path: apps/web/playwright-report/
          retention-days: 7

      - name: Comment E2E results on PR
        if: always()
        uses: ./.github/actions/post-e2e-results
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          pr-number: ${{ needs.detect-changes.outputs.pr_number }}
          test-outcome: ${{ steps.run-tests.outcome }}
          preview-url: ${{ needs.get-ingress.outputs.preview_url }}
          commit-sha: ${{ needs.detect-changes.outputs.pr_head_sha }}
          run-id: ${{ github.run_id }}
          repository: ${{ github.repository }}

  # ---------------------------------------------------------------------------
  # Preview Status Check - Required Check for Merge
  # ---------------------------------------------------------------------------
  # Preview Status Check (aggregates all job results into single required check for merge gating)
  # ---------------------------------------------------------------------------
  preview-status-check:
    name: Preview Status Check
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') && always()
    env:
      NEEDS_IMAGE_BUILD: ${{ needs.detect-changes.outputs.needs_image_build }}
      NEEDS_DEPLOYMENT: ${{ needs.detect-changes.outputs.needs_deployment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Query job statuses and build summary
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          NEEDS_IMAGE_BUILD: ${{ needs.detect-changes.outputs.needs_image_build }}
          NEEDS_DEPLOYMENT: ${{ needs.detect-changes.outputs.needs_deployment }}
        run: |
          python - <<'PY'
import os, sys, json, urllib.request
GITHUB_TOKEN = os.environ['GITHUB_TOKEN']
REPO = os.environ['REPO']
RUN_ID = os.environ['RUN_ID']
NEEDS_DEPLOYMENT = os.environ.get('NEEDS_DEPLOYMENT','false')
headers = {'Authorization': f'token {GITHUB_TOKEN}', 'Accept': 'application/vnd.github.v3+json'}
url = f'https://api.github.com/repos/{REPO}/actions/runs/{RUN_ID}/jobs'
req = urllib.request.Request(url, headers=headers)
with urllib.request.urlopen(req) as r:
    data = json.load(r)
jobs = data.get('jobs', [])

# Helper to find job conclusion by display name
def conclusion(name):
    for j in jobs:
        if j.get('name') == name:
            return j.get('conclusion') or 'skipped'
    return 'skipped'

update_overlay = conclusion('Update Preview Overlay')
verify_deployment = conclusion('Verify Deployment')
deploy_frontend = conclusion('Deploy Frontend Preview')
e2e = conclusion('E2E Tests')
get_ingress = conclusion('Get Ingress Info')

# Build summary
summary_lines = []
summary_lines.append('## Preview Pipeline Status')
summary_lines.append('')
if NEEDS_DEPLOYMENT != 'true':
    summary_lines.append('üìù No deployment needed - docs-only PR')
    summary_lines.append('')
    summary_lines.append('| Job | Status |')
    summary_lines.append('|-----|--------|')
    summary_lines.append('| Detect Changes | ‚úÖ No deployment needed |')
    print('\n'.join(summary_lines))
    sys.exit(0)

# E2E logic: require only if ingress succeeded
api_configured = get_ingress == 'success'
if not api_configured:
    e2e_status = '‚è≠Ô∏è Skipped (no API URL)'
else:
    if e2e == 'success':
        e2e_status = '‚úÖ Passed'
    elif e2e == 'skipped':
        e2e_status = '‚è≠Ô∏è Skipped'
    else:
        e2e_status = '‚ùå Failed'

summary_lines.append('| Job | Status |')
summary_lines.append('|-----|--------|')

# Helper to format job results safely
def fmt_result(res):
    if res == 'success':
        return '‚úÖ Success'
    if res == 'skipped':
        return '‚è≠Ô∏è Skipped'
    return '‚ùå Failed'

summary_lines.append(f"| Update Overlay | {fmt_result(update_overlay)} |")
summary_lines.append(f"| Verify Deployment | {fmt_result(verify_deployment)} |")
summary_lines.append(f"| Deploy Frontend | {fmt_result(deploy_frontend)} |")
summary_lines.append(f"| E2E Tests | {e2e_status} |")

print('\n'.join(summary_lines))

# Determine exit codes similar to previous behavior
if update_overlay != 'success':
    print('::error::Update overlay failed')
    sys.exit(1)
if verify_deployment != 'success':
    print('::error::Deployment verification failed - pods may not be running correct image')
    sys.exit(1)
if deploy_frontend != 'success':
    print('::error::Frontend deployment failed')
    sys.exit(1)
if api_configured and e2e != 'success':
    print('::error::E2E tests failed')
    sys.exit(1)

print('‚úÖ Preview pipeline completed successfully!')
PY

