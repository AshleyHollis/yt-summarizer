# =============================================================================
# Deploy to Production Workflow
# =============================================================================
# Automatically deploys to production when a PR is merged to main
# Updates prod overlay with image digests, Argo CD syncs automatically
# NO manual approval gates - relies on PR review process
#
# SIMPLIFIED STRATEGY:
# -------------------
# - Always runs terraform/deploy jobs (predictable behavior)
# - Uses CI-built images (sha-{commit}) for consistency
# - Removed detect-changes logic for reliability and debuggability
#
# IMAGE BUILD STRATEGY:
#   - CI builds images as sha-{commit} when code is pushed to main
#   - Production waits for CI and uses those tested images
#   - Each deployment is traceable to a specific git commit
#
# EXTRACTED SCRIPTS:
#   - scripts/workflows/prod-extract-ci-image-tag.sh: Get image tag from CI workflow
#
# See also: preview.yml for PR-scoped image strategy
#           ci.yml for image building logic

name: Deploy to Production

on:
  push:
    branches: [main]
    paths-ignore:
      - "*.md"
      - "docs/**"
      - "specs/**"
      - "k8s/overlays/previews/**"
  workflow_dispatch:
    inputs:
      run_terraform:
        description: 'Run terraform plan/apply'
        required: false
        type: boolean
        default: true
      run_deploy:
        description: 'Build and deploy backend'
        required: false
        type: boolean
        default: true
      run_frontend:
        description: 'Deploy frontend'
        required: false
        type: boolean
        default: true
      run_health_check:
        description: 'Run post-deploy health checks'
        required: false
        type: boolean
        default: true


concurrency:
  group: deploy-prod
  cancel-in-progress: false

env:
  # Shared variables are loaded from .github/config/shared.env via load-shared-env action
  # Only environment-specific overrides and GitHub variables are set here

  # GitHub Variables (can override shared.env defaults)
  ACR_NAME: ${{ vars.ACR_NAME || 'acrytsummprd' }}
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}

  # Production-specific values
  ARGOCD_APP_NAME_PROD: 'yt-summarizer-prod'
  NAMESPACE_PROD: 'yt-summarizer'
  PRODUCTION_URL: ${{ vars.PRODUCTION_URL || 'https://api.yt-summarizer.example.com' }}
  ARGOCD_SYNC_TIMEOUT: '360'  # Longer timeout for production
  KUSTOMIZE_OVERLAY_PROD: 'k8s/overlays/prod'

permissions:
  id-token: write
  contents: write


jobs:
  # ---------------------------------------------------------------------------
  # Wait for CI to succeed (auto-apply gate)
  # ---------------------------------------------------------------------------
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    outputs:
      ci_run_id: ${{ steps.wait.outputs.ci_run_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for CI workflow to complete
        id: wait
        uses: ./.github/actions/wait-for-ci
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          commit-sha: ${{ github.sha }}
          timeout-seconds: '1800'

  # ---------------------------------------------------------------------------
  # Terraform (Plan + Apply)
  # ---------------------------------------------------------------------------
  terraform:
    name: Terraform
    uses: ./.github/workflows/terraform-deploy.yml
    needs: [wait-for-ci]
    permissions:
      id-token: write       # For Azure OIDC authentication
      contents: read        # For checking out code
      pull-requests: write  # Required by terraform-plan job (even when post-to-pr: false)
    if: |
      needs.wait-for-ci.result == 'success' &&
      ((github.event_name == 'workflow_dispatch' && inputs.run_terraform != false) ||
       (github.event_name != 'workflow_dispatch'))
    with:
      environment: production
      terraform-version: ${{ vars.TERRAFORM_VERSION || '1.5.7' }}
      working-directory: infra/terraform/environments/prod
      run-plan: true
      run-apply: true
      require-changes: true
      post-to-pr: false
    secrets: inherit

  # ---------------------------------------------------------------------------
  # Sync Argo CD Manifests
  # ---------------------------------------------------------------------------
  sync-argocd-manifests:
    name: Sync Argo CD Manifests
    runs-on: ubuntu-latest
    needs: [terraform]
    if: |
      !cancelled() &&
      needs.terraform.result != 'failure'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load shared environment
        uses: ./.github/actions/load-shared-env

      - name: Setup Azure and AKS
        uses: ./.github/actions/setup-azure-aks
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Sync Argo CD manifests
        uses: ./.github/actions/sync-argocd-manifests
        with:
          mode: all
          namespace: ${{ env.NAMESPACE_ARGOCD }}
          verbose: 'true'

  # ---------------------------------------------------------------------------
  # Get Image Tag from CI
  # ---------------------------------------------------------------------------
  get-image-tag:
    name: Get Image Tag
    runs-on: ubuntu-latest
    needs: [wait-for-ci, terraform, sync-argocd-manifests]
    if: |
      !cancelled() &&
      needs.wait-for-ci.result == 'success' &&
      needs.terraform.result != 'failure' &&
      needs.sync-argocd-manifests.result != 'failure' &&
      ((github.event_name == 'workflow_dispatch' && inputs.run_deploy != false) ||
       (github.event_name != 'workflow_dispatch'))
    outputs:
      image_tag: ${{ steps.normalize-tag.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load shared environment
        uses: ./.github/actions/load-shared-env

      - name: Extract image tag from CI
        id: extract
        shell: bash
        run: scripts/workflows/prod-extract-ci-image-tag.sh

      - name: Normalize image tag
        id: normalize-tag
        shell: bash
        run: |
          image_tag="${{ steps.extract.outputs.image_tag }}"
          if [ -z "$image_tag" ]; then
            short_sha="${GITHUB_SHA:0:7}"
            image_tag="sha-${short_sha}"
            echo "::warning::Image tag output was empty; falling back to ${image_tag}"
          fi
          echo "image_tag=$image_tag" >> "$GITHUB_OUTPUT"

      - name: Azure Login and ACR authentication
        uses: ./.github/actions/azure-acr-login
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          acr-name: ${{ env.ACR_NAME }}

      - name: Validate CI image exists in ACR
        uses: ./.github/actions/validate-docker-image
        with:
          validation-type: acr-exists
          image-tag: ${{ steps.normalize-tag.outputs.image_tag }}
          registry: ${{ env.ACR_NAME }}
          repository: ${{ env.API_IMAGE_NAME }}
          fail-if-missing: 'true'

  # ---------------------------------------------------------------------------
  # Update Production Overlay
  # ---------------------------------------------------------------------------
  update-overlay:
    name: Update Production Overlay
    runs-on: ubuntu-latest
    needs: [wait-for-ci, terraform, sync-argocd-manifests, get-image-tag]
    if: |
      always() && !cancelled() &&
      needs.wait-for-ci.result == 'success' &&
      needs.terraform.result != 'failure' &&
      needs.sync-argocd-manifests.result != 'failure' &&
      needs.get-image-tag.result == 'success'
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.DEPLOY_APP_ID }}
          private-key: ${{ secrets.DEPLOY_APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}

      - name: Load shared environment
        uses: ./.github/actions/load-shared-env

      - name: Setup Python with dependencies
        uses: ./.github/actions/setup-kustomize
        with:
          install-python: 'true'

      # NOTE: CI has already validated prod overlay before this branch was created.
      # This baseline check is kept as a safety net in case kustomization.yaml was
      # modified after merge, though merge commits cannot modify files without
      # triggering a new CI validation. Kept for defensive robustness.
      - name: Validate current production overlay (baseline)
        uses: ./.github/actions/validate
        with:
          validators: kustomize-build
          overlay-paths: ${{ env.KUSTOMIZE_OVERLAY_PROD }}
          fail-fast: 'true'
          timeout-seconds: '30'

      - name: Set image tag
        id: determine-tag
        shell: bash
        run: |
          echo "image_tag=${{ needs.get-image-tag.outputs.image_tag }}" >> "$GITHUB_OUTPUT"

      - name: Update production kustomization
        uses: ./.github/actions/manage-kustomization
        with:
          operation: update-prod
          image-tag: ${{ steps.determine-tag.outputs.image_tag }}
          kustomization-path: k8s/overlays/prod
          template-path: scripts/ci/templates/prod-kustomization-template.yaml
          auto-commit: 'true'
          git-branch: main

      # This validation is critical - it runs AFTER update-prod-kustomization
      # inserts image tags. Ensures the modified manifest is still valid.
      # This is where we catch errors introduced by the kustomization update action.
      - name: Validate updated production overlay
        uses: ./.github/actions/validate
        with:
          validators: kustomize-build
          overlay-paths: ${{ env.KUSTOMIZE_OVERLAY_PROD }}
          fail-fast: 'true'
          timeout-seconds: '30'

      - name: Setup Azure and AKS
        uses: ./.github/actions/setup-azure-aks
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Verify cluster can pull image
        uses: ./.github/actions/validate-docker-image
        with:
          validation-type: acr-exists
          image-tag: ${{ steps.determine-tag.outputs.image_tag }}
          registry: ${{ env.ACR_NAME }}
          repository: ${{ env.API_IMAGE_NAME }}
          run-k8s-pull-test: 'true'

      - name: Validate image tag format
        if: needs.get-image-tag.result == 'success'
        uses: ./.github/actions/validate-docker-image
        with:
          validation-type: tag-format
          image-tag: ${{ steps.determine-tag.outputs.image_tag }}
          commit-sha: ${{ github.sha }}

      - name: Commit and push changes
        uses: ./.github/actions/commit-kustomization
        with:
          file-path: '${{ env.KUSTOMIZE_OVERLAY_PROD }}/kustomization.yaml'
          commit-message: |
            chore(prod): deploy ${{ steps.determine-tag.outputs.image_tag }} to production

            API Image:
              ${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE_NAME }}:${{ steps.determine-tag.outputs.image_tag }}
            Workers Image:
              ${{ env.ACR_LOGIN_SERVER }}/${{ env.WORKERS_IMAGE_NAME }}:${{ steps.determine-tag.outputs.image_tag }}

            Commit: ${{ github.sha }}
            Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            [skip ci]
          git-branch: 'main'


  # ---------------------------------------------------------------------------
  # Verify Deployment
  # ---------------------------------------------------------------------------
  # Comprehensive deployment verification after overlay update
  # - Validate Argo CD manifest before sync (early error detection)
  # - Wait for ArgoCD sync with fail-fast manifest error detection
  # - Verify API and worker deployment images
  # - Run health checks
  # - Verify TLS certificate
  # ---------------------------------------------------------------------------
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [update-overlay, get-image-tag]
    if: |
      !cancelled() &&
      needs.update-overlay.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load shared environment
        uses: ./.github/actions/load-shared-env

      - name: Setup Azure and AKS
        uses: ./.github/actions/setup-azure-aks
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-ytsumm-prd' }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME || 'aks-ytsumm-prd' }}

      - name: Setup Kustomize
        uses: ./.github/actions/setup-kustomize
        with:
          kustomize-version: ${{ env.KUSTOMIZE_VERSION }}

      - name: Cleanup and wait for Argo CD to sync
        uses: ./.github/actions/argocd-wait
        with:
          app-name: ${{ env.ARGOCD_APP_NAME_PROD }}
          namespace: ${{ env.NAMESPACE_PROD }}
          argocd-namespace: ${{ env.NAMESPACE_ARGOCD }}
          cleanup-stuck-operations: 'true'
          auto-recovery: 'false'
          max-wait-seconds: ${{ env.ARGOCD_SYNC_TIMEOUT }}
          poll-interval-seconds: '5'
          pr-number: '0'

      - name: Set expected image tag
        id: expected-tag
        shell: bash
        run: |
          echo "image_tag=${{ needs.get-image-tag.outputs.image_tag }}" >> "$GITHUB_OUTPUT"

      - name: Verify deployments are using correct image tag
        uses: ./.github/actions/verify-k8s-deployment
        with:
          namespace: ${{ env.NAMESPACE_PROD }}
          deployments: api,transcribe-worker,summarize-worker
          expected-tag: ${{ steps.expected-tag.outputs.image_tag }}
          registry: ${{ vars.ACR_LOGIN_SERVER || 'acrytsummprd.azurecr.io' }}
          image-name: yt-summarizer
          wait-for-ready: 'true'
          timeout-seconds: '300'

      - name: Collect and upload diagnostics on failure
        if: failure()
        uses: ./.github/actions/collect-deployment-diagnostics
        with:
          app-name: ${{ env.ARGOCD_APP_NAME_PROD }}
          artifact-name: deployment-diagnostics-prod

      - name: Verify TLS certificate
        uses: ./.github/actions/verify-certificate
        with:
          host: api.yt-summarizer.apps.ashleyhollis.com

      - name: Run external API health check
        uses: ./.github/actions/health-check
        with:
          url: ${{ env.PRODUCTION_URL }}${{ env.HEALTH_CHECK_PATH }}
          max-attempts: '20'
          interval-seconds: '10'
          timeout-seconds: '5'
          expected-status: '200'
          service-name: 'Production API (External)'

      - name: Run API health checks
        uses: ./.github/actions/health-check
        with:
          url: ${{ env.PRODUCTION_URL }}/health
          max-attempts: ${{ env.HEALTH_CHECK_MAX_ATTEMPTS }}
          interval-seconds: ${{ env.HEALTH_CHECK_INTERVAL }}
          timeout-seconds: ${{ env.HEALTH_CHECK_TIMEOUT }}
          expected-status: '200'
          service-name: 'Production API'

  # ---------------------------------------------------------------------------
  # Deploy Frontend to SWA
  # ---------------------------------------------------------------------------
  # DECOUPLED FROM BACKEND: Frontend deployment is independent of backend jobs.
  # Frontend can deploy whenever:
  #   - apps/web code changes (auto)
  #   - Workflow dispatch with run_frontend=true (manual)
  #   - Workflow/CI files change (for env var updates)
  #
  # This allows frontend-only deployments without requiring backend image validation.
  # ---------------------------------------------------------------------------
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [wait-for-ci]
    if: |
      !cancelled() &&
      needs.wait-for-ci.result == 'success' &&
      ((github.event_name == 'workflow_dispatch' && inputs.run_frontend != false) ||
       (github.event_name != 'workflow_dispatch'))
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load shared environment
        uses: ./.github/actions/load-shared-env

      - name: Deploy frontend with CI artifact
        id: deploy-frontend
        uses: ./.github/actions/deploy-frontend-swa
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          ci-run-id: ${{ needs.wait-for-ci.outputs.ci_run_id }}
          api-url: ${{ vars.PRODUCTION_API_URL || env.PRODUCTION_URL }}
          swa-token: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
          app-location: apps/web
          runtime-config-path: apps/web/public/runtime-config.js
          output_location: ""
          production-branch: main
          deployment-environment: production

      - name: Verify frontend deployment
        uses: ./.github/actions/health-check
        with:
          url: ${{ steps.deploy-frontend.outputs.static_web_app_url || vars.PRODUCTION_WEB_URL || 'https://web.yt-summarizer.apps.ashleyhollis.com' }}
          max-attempts: ${{ env.HEALTH_CHECK_MAX_ATTEMPTS }}
          interval-seconds: ${{ env.HEALTH_CHECK_INTERVAL }}
          timeout-seconds: ${{ env.HEALTH_CHECK_TIMEOUT }}
          expected-status: '200'
          service-name: 'Production Web'

  # ---------------------------------------------------------------------------
  # Deployment Summary
  # ---------------------------------------------------------------------------
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs:
      - get-image-tag
      - sync-argocd-manifests
      - update-overlay
      - verify-deployment
      - deploy-frontend
      - wait-for-ci
      - terraform
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load shared environment
        uses: ./.github/actions/load-shared-env

      - name: Write execution rationale
        run: |
          {
            echo "## Prod Deployment Summary"
            echo ""
            echo "- Wait for CI: ${{ needs.wait-for-ci.result }}"
            terraform_plan_changes="n/a"
            if [[ "${{ needs.terraform.result }}" == 'success' ]]; then
              terraform_plan_changes="${{ fromJson(needs.terraform.outputs.plan-summary).has_changes }}"
            fi
            echo "- Terraform plan: ${{ needs.terraform.result }}"
            echo "  changes: ${terraform_plan_changes}"
            echo "- Terraform apply: ${{ needs.terraform.result }}"
            echo "- Argo CD manifests sync: ${{ needs.sync-argocd-manifests.result }}"
            echo "- Backend deploy tag: ${{ needs.get-image-tag.outputs.image_tag || 'n/a' }}"
            echo "- Overlay update: ${{ needs.update-overlay.result }}"
            echo "- Deployment verification: ${{ needs.verify-deployment.result }}"
            echo "- Frontend deploy: ${{ needs.deploy-frontend.result }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Generate summary
        uses: ./.github/actions/create-pipeline-summary
        with:
          summary-type: prod
          image-tag: ${{ needs.get-image-tag.outputs.image_tag }}
          commit-sha: ${{ github.sha }}
          update-overlay-result: ${{ needs.update-overlay.result }}
          verify-deployment-result: ${{ needs.verify-deployment.result }}
          deploy-frontend-result: ${{ needs.deploy-frontend.result }}
