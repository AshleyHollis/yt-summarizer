name: 'Terraform Plan'
description: 'Runs terraform plan and captures output for PR comments'
inputs:
  working-directory:
    description: 'Working directory for terraform commands'
    required: true
  subscription-id:
    description: 'Azure subscription ID'
    required: true
  sql-admin-password:
    description: 'SQL admin password'
    required: true
outputs:
  plan_output:
    description: 'Raw terraform plan output'
    value: ${{ steps.plan.outputs.plan_output }}
  formatted_plan:
    description: 'Formatted plan for PR comments'
    value: ${{ steps.format.outputs.formatted_plan }}
  plan_summary:
    description: 'JSON summary of plan changes'
    value: ${{ steps.format.outputs.plan_summary }}
  outcome:
    description: 'Plan outcome (success/failure)'
    value: ${{ steps.plan.outcome }}
runs:
  using: composite
  steps:
    - name: Run terraform plan
      id: plan
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        set -o pipefail
        terraform plan -no-color -input=false -out=tfplan \
          -var="subscription_id=${{ inputs.subscription-id }}" \
          -var="sql_admin_password=${{ inputs.sql-admin-password }}" \
          2>&1 | tee plan_output.txt
        PLAN_EXIT_CODE=$?
        echo "plan_output<<EOF" >> "$GITHUB_OUTPUT"
        cat plan_output.txt >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"
        exit $PLAN_EXIT_CODE
      continue-on-error: true

    - name: Format plan output
      id: format
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Parse plan summary
        ADD=$(grep -oP 'Plan: \K\d+(?= to add)' plan_output.txt || echo "0")
        CHANGE=$(grep -oP '\d+(?= to change)' plan_output.txt || echo "0")
        DESTROY=$(grep -oP '\d+(?= to destroy)' plan_output.txt || echo "0")

        # Create JSON summary
        SUMMARY=$(cat <<EOF
        {
          "add": $ADD,
          "change": $CHANGE,
          "destroy": $DESTROY,
          "has_changes": $([ $ADD -gt 0 ] || [ $CHANGE -gt 0 ] || [ $DESTROY -gt 0 ] && echo "true" || echo "false")
        }
        EOF
        )

        echo "plan_summary<<EOF" >> "$GITHUB_OUTPUT"
        echo "$SUMMARY" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"

        # Extract resource changes - capture resource blocks with all content including closing braces
        FORMATTED=""
        IN_RESOURCE=false
        while IFS= read -r line; do
          # Start of a resource
          if [[ "$line" =~ ^[[:space:]]*#[[:space:]] ]]; then
            IN_RESOURCE=true
            FORMATTED+="$line"$'\n'
          # If we're in a resource, capture everything until we hit Plan: or similar
          elif $IN_RESOURCE; then
            if [[ "$line" =~ ^Plan:|^Changes\ to\ Outputs:|^Warning: ]]; then
              IN_RESOURCE=false
            else
              # Capture the line if it has content or is a brace line
              if [[ -n "$(echo "$line" | tr -d '[:space:]')" ]]; then
                FORMATTED+="$line"$'\n'
              fi
            fi
          fi
        done < plan_output.txt

        # If no formatted content, use full output
        if [ -z "$FORMATTED" ]; then
          FORMATTED=$(cat plan_output.txt)
        fi

        echo "formatted_plan<<EOF" >> "$GITHUB_OUTPUT"
        echo "$FORMATTED" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"
