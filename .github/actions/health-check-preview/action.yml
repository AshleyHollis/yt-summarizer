name: 'Health Check Preview Environment'
description: 'Performs health checks on preview environment API (internal cluster + external ingress)'
inputs:
  namespace:
    description: 'Kubernetes namespace for the preview environment'
    required: true
  external-url:
    description: 'External URL to check (e.g., https://api.preview-pr-4.example.com)'
    required: true
  max-attempts:
    description: 'Maximum number of health check attempts'
    required: false
    default: '10'
  interval-seconds:
    description: 'Seconds to wait between attempts'
    required: false
    default: '10'

runs:
  using: 'composite'
  steps:
    - name: Check internal cluster health
      shell: bash
      run: |
        NAMESPACE="${{ inputs.namespace }}"
        MAX_ATTEMPTS="${{ inputs.max-attempts }}"
        INTERVAL="${{ inputs.interval-seconds }}"
        
        echo "ðŸ” Checking API health from within cluster..."
        echo "Namespace: ${NAMESPACE}"
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "Attempt $i/$MAX_ATTEMPTS (internal)..."
          
          # Run curl from within the cluster to check internal service
          if kubectl run curl-test-internal-${i} \
            --image=curlimages/curl:latest \
            --rm -i --restart=Never \
            --namespace=${NAMESPACE} \
            --timeout=15s \
            -- curl -s --max-time 5 http://api/health/live 2>/dev/null | grep -q "ok"; then
            echo "âœ… Internal API health check passed"
            break
          fi
          
          if [ $i -lt $MAX_ATTEMPTS ]; then
            echo "  â³ Waiting ${INTERVAL}s before retry..."
            sleep $INTERVAL
          else
            echo "::error::Internal API health check failed after $MAX_ATTEMPTS attempts"
            exit 1
          fi
        done

    - name: Check DNS resolution
      shell: bash
      run: |
        EXTERNAL_URL="${{ inputs.external-url }}"
        
        # Extract hostname from URL
        HOSTNAME=$(echo "$EXTERNAL_URL" | sed -E 's|https?://([^/]+).*|\1|')
        
        echo "ðŸŒ Checking DNS resolution..."
        echo "Hostname: ${HOSTNAME}"
        
        # Try to resolve the hostname
        if command -v nslookup >/dev/null 2>&1; then
          echo "--- nslookup output ---"
          nslookup ${HOSTNAME} || echo "::warning::DNS resolution failed"
        fi
        
        if command -v dig >/dev/null 2>&1; then
          echo "--- dig output ---"
          dig +short ${HOSTNAME} || echo "::warning::dig failed"
        fi
        
        # Check if hostname resolves to expected IP
        RESOLVED_IP=$(getent hosts ${HOSTNAME} | awk '{ print $1 }' || echo "")
        if [ -n "$RESOLVED_IP" ]; then
          echo "âœ… Hostname resolves to: ${RESOLVED_IP}"
        else
          echo "::warning::Failed to resolve hostname"
        fi

    - name: Check TLS certificate status
      shell: bash
      run: |
        NAMESPACE="${{ inputs.namespace }}"
        
        echo "ðŸ” Checking TLS certificate status..."
        
        # Get certificate status
        CERT_NAME=$(kubectl get certificate -n ${NAMESPACE} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        
        if [ -z "$CERT_NAME" ]; then
          echo "âš ï¸  No certificate found in namespace ${NAMESPACE}"
        else
          echo "Certificate: $CERT_NAME"
          
          # Get certificate ready status
          CERT_READY=$(kubectl get certificate ${CERT_NAME} -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
          CERT_REASON=$(kubectl get certificate ${CERT_NAME} -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Ready")].reason}' 2>/dev/null || echo "Unknown")
          CERT_MESSAGE=$(kubectl get certificate ${CERT_NAME} -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Ready")].message}' 2>/dev/null || echo "Unknown")
          
          echo "  Ready: ${CERT_READY}"
          echo "  Reason: ${CERT_REASON}"
          
          if [ "$CERT_READY" != "True" ]; then
            echo "::warning::TLS certificate is not ready"
            echo "  Message: ${CERT_MESSAGE}"
            
            # Check if it's a rate limit issue
            if echo "$CERT_MESSAGE" | grep -q "rateLimited"; then
              echo "::error::Let's Encrypt rate limit detected!"
              echo "::notice::The domain has exceeded Let's Encrypt's certificate issuance limit"
              echo "::notice::Rate limit: 5 certificates per exact domain set per 168 hours"
              echo "::notice::Options:"
              echo "::notice::  1. Wait for the rate limit window to expire"
              echo "::notice::  2. Use a different domain/subdomain"
              echo "::notice::  3. Temporarily use letsencrypt-staging issuer"
              
              # Extract retry time if available
              RETRY_AFTER=$(echo "$CERT_MESSAGE" | grep -oP 'retry after \K[^:]+' || echo "")
              if [ -n "$RETRY_AFTER" ]; then
                echo "::notice::Rate limit resets: ${RETRY_AFTER}"
              fi
            fi
          else
            echo "âœ… Certificate is ready"
          fi
        fi

    - name: Check ingress configuration
      shell: bash
      run: |
        NAMESPACE="${{ inputs.namespace }}"
        
        echo "ðŸ”§ Checking ingress configuration..."
        
        # Get ingress details
        kubectl get ingress -n ${NAMESPACE} -o wide || echo "::warning::Failed to get ingress"
        
        # Check ingress backend status
        echo "--- Ingress Backend Status ---"
        kubectl describe ingress -n ${NAMESPACE} | grep -A 5 "Backend:" || true
        
        # Check if ingress has an address
        INGRESS_ADDRESS=$(kubectl get ingress -n ${NAMESPACE} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        if [ -n "$INGRESS_ADDRESS" ]; then
          echo "âœ… Ingress has address: ${INGRESS_ADDRESS}"
        else
          echo "::warning::Ingress does not have an assigned address yet"
        fi

    - name: Check service and endpoints
      shell: bash
      run: |
        NAMESPACE="${{ inputs.namespace }}"
        
        echo "ðŸ”Œ Checking service and endpoints..."
        
        # Check service
        kubectl get svc api -n ${NAMESPACE} -o wide || echo "::warning::Service not found"
        
        # Check endpoints
        echo "--- Endpoints ---"
        kubectl get endpoints api -n ${NAMESPACE} || echo "::warning::Endpoints not found"
        
        # Check if endpoints have addresses
        ENDPOINT_COUNT=$(kubectl get endpoints api -n ${NAMESPACE} -o jsonpath='{.subsets[0].addresses}' 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
        if [ "$ENDPOINT_COUNT" != "0" ]; then
          echo "âœ… Service has ${ENDPOINT_COUNT} endpoint(s)"
        else
          echo "::error::Service has no endpoints - pods may not be ready"
        fi

    - name: Diagnose external connectivity
      shell: bash
      run: |
        EXTERNAL_URL="${{ inputs.external-url }}"
        
        echo "ðŸ” Diagnosing external connectivity..."
        echo "URL: ${EXTERNAL_URL}/health/live"
        
        # Test with verbose output and capture SSL info
        echo "--- Detailed Connection Test ---"
        curl -v --max-time 10 "${EXTERNAL_URL}/health/live" 2>&1 | grep -E "SSL|TLS|certificate|HTTP|Connected|Trying" || true
        
        # Test with insecure to see if it's just a cert issue
        echo ""
        echo "--- Testing with SSL verification bypass ---"
        INSECURE_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" --max-time 5 "${EXTERNAL_URL}/health/live" || echo "000")
        echo "HTTP Status (with -k): ${INSECURE_CODE}"
        
        if [ "$INSECURE_CODE" = "200" ]; then
          echo "::warning::API is accessible when SSL verification is bypassed"
          echo "::notice::This confirms the issue is TLS certificate related"
          echo "::notice::The ingress is working, but the certificate is invalid/missing"
        fi

    - name: Check external ingress health
      shell: bash
      run: |
        EXTERNAL_URL="${{ inputs.external-url }}"
        MAX_ATTEMPTS="${{ inputs.max-attempts }}"
        INTERVAL="${{ inputs.interval-seconds }}"
        NAMESPACE="${{ inputs.namespace }}"
        
        echo "ðŸŒ Checking API health via external ingress..."
        echo "URL: ${EXTERNAL_URL}/health/live"
        
        # Check certificate status first
        CERT_READY=$(kubectl get certificate -n ${NAMESPACE} -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
        CERT_MESSAGE=$(kubectl get certificate -n ${NAMESPACE} -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].message}' 2>/dev/null || echo "")
        
        if [ "$CERT_READY" != "True" ]; then
          echo "::warning::TLS certificate is not ready - external health check will likely fail"
          
          # Check if it's the DNS provider global rate limit
          if echo "$CERT_MESSAGE" | grep -qi "too many certificates.*sslip.io\|too many certificates.*nip.io"; then
            echo "::warning::DNS provider has hit its global rate limit (25,000 certs per 168 hours)"
            echo "::notice::This is a shared rate limit across all users of the DNS provider globally"
            echo "::notice::The preview environment is fully functional on internal cluster network"
            echo "::notice::External HTTPS access is temporarily unavailable due to DNS provider limitations"
            echo "::notice::Skipping external health check - internal checks passed"
            exit 0
          fi
        fi
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "Attempt $i/$MAX_ATTEMPTS (external)..."
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "${EXTERNAL_URL}/health/live" 2>&1 || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… External API health check passed (HTTP $HTTP_CODE)"
            exit 0
          else
            echo "  âŒ Status: $HTTP_CODE (expected: 200)"
          fi
          
          if [ $i -lt $MAX_ATTEMPTS ]; then
            echo "  â³ Waiting ${INTERVAL}s before retry..."
            sleep $INTERVAL
          fi
        done
        
        # Final diagnostics before failing
        echo ""
        
        # Check if it's a cert issue
        INSECURE_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" --max-time 5 "${EXTERNAL_URL}/health/live" 2>/dev/null || echo "000")
        if [ "$INSECURE_CODE" = "200" ]; then
          echo "::warning::External API health check failed due to TLS certificate issue"
          echo "::notice::The preview environment is deployed and healthy (works with -k flag)"
          echo "::notice::External HTTPS access is blocked by invalid/missing TLS certificate"
          
          # Check cert status again for detailed error
          if echo "$CERT_MESSAGE" | grep -qi "rateLimited"; then
            echo "::notice::Certificate provisioning failed due to Let's Encrypt rate limiting"
            if echo "$CERT_MESSAGE" | grep -qi "sslip.io\|nip.io\|xip.io"; then
              echo "::notice::The wildcard DNS provider has exceeded its global rate limit"
              echo "::notice::Consider using a custom domain or switching DNS providers"
            fi
            echo "::notice::Treating as non-critical - deployment is functional on internal network"
            exit 0
          fi
          
          exit 1
        fi
        
        echo "::error::External API health check failed after $MAX_ATTEMPTS attempts"
        echo "::notice::Possible causes:"
        echo "::notice::- DNS propagation delay for sslip.io (usually resolves in 1-2 minutes)"
        echo "::notice::- TLS certificate provisioning in progress"
        echo "::notice::- Ingress controller configuration issues"
        echo "::notice::- Network policy restrictions"
        exit 1
