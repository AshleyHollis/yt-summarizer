#!/bin/bash
# Unified commit script for kustomization changes
# Handles preview, prod, and generic commit operations

set -euo pipefail

# Determine what to commit based on operation
case "$OPERATION" in
  update-preview)
    # Preview overlays are stored in PR-specific directories on the preview-overlays branch
    # This prevents commits to PR branches which would invalidate CI status
    FILE_TO_COMMIT="${OVERLAY_PATH:-k8s/overlays/preview-pr-${PR_NUMBER}}/kustomization.yaml"
    BRANCH="preview-overlays"
    MESSAGE="ci(preview): update overlay for PR #${PR_NUMBER} with image ${IMAGE_TAG}

- Image: ${IMAGE_TAG}
- Commit: ${COMMIT_SHA:0:7}
- PR Branch: ${PR_BRANCH}
- Auto-generated by GitHub Actions

[skip ci]"
    ;;

  update-prod)
    FILE_TO_COMMIT="${KUSTOMIZATION_PATH}/kustomization.yaml"
    BRANCH="${GIT_BRANCH}"
    MESSAGE="ci(prod): update kustomization with image ${IMAGE_TAG}

- Image: ${IMAGE_TAG}
- Auto-generated by GitHub Actions

[skip ci]"
    ;;

  commit-only)
    FILE_TO_COMMIT="${FILE_PATH}"
    BRANCH="${GIT_BRANCH}"
    MESSAGE="${COMMIT_MESSAGE}"
    ;;

  *)
    echo "::error::Invalid operation: $OPERATION"
    exit 1
    ;;
esac

echo "ðŸ“ Committing changes..."
echo "  File: $FILE_TO_COMMIT"
echo "  Branch: $BRANCH"

# Configure git
git config user.name "github-actions[bot]"
git config user.email "github-actions[bot]@users.noreply.github.com"

# For preview overlays, we need to work with the dedicated preview-overlays branch
if [ "$OPERATION" == "update-preview" ]; then
  echo "ðŸ”„ Setting up preview-overlays branch..."

  # Save the current branch/ref so we can return to it later
  ORIGINAL_REF=$(git rev-parse HEAD)
  ORIGINAL_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")

  # The overlay file was generated in the current branch but needs to be committed to preview-overlays
  # Move it to a temp location before switching branches to avoid git conflicts
  TEMP_FILE="/tmp/preview-overlay-${PR_NUMBER}.yaml"
  if [ -f "$FILE_TO_COMMIT" ]; then
    echo "ðŸ“¦ Saving generated overlay to temp location..."
    cp "$FILE_TO_COMMIT" "$TEMP_FILE"
    # Remove the directory to avoid checkout conflicts
    rm -rf "$(dirname "$FILE_TO_COMMIT")"
  else
    echo "::error::Preview overlay file not found at $FILE_TO_COMMIT. Was update-preview.sh run first?"
    exit 1
  fi

  # Fetch the preview-overlays branch if it exists
  git fetch origin "$BRANCH" 2>/dev/null || true

  # Check if remote branch exists
  if git rev-parse "origin/$BRANCH" > /dev/null 2>&1; then
    # Branch exists, check it out
    git checkout -B "$BRANCH" "origin/$BRANCH"
  else
    # Branch doesn't exist, create it as orphan from main
    echo "â„¹ï¸  Creating new preview-overlays branch..."
    git checkout --orphan "$BRANCH"
    # Remove all files from staging (orphan branch)
    git rm -rf . 2>/dev/null || true
  fi

  # Ensure the PR-specific overlay directory exists
  OVERLAY_DIR="$(dirname "$FILE_TO_COMMIT")"
  mkdir -p "$OVERLAY_DIR"

  # Restore the overlay file from temp location
  echo "ðŸ“¥ Restoring overlay file to preview-overlays branch..."
  cp "$TEMP_FILE" "$FILE_TO_COMMIT"
  rm "$TEMP_FILE"
fi

# Check if file exists (should exist by now)
if [ ! -f "$FILE_TO_COMMIT" ]; then
  echo "::error::File not found: $FILE_TO_COMMIT"
  exit 1
fi

# Check if there are changes (for tracked files) or if file is new
if git diff --quiet "$FILE_TO_COMMIT" 2>/dev/null && git ls-files --error-unmatch "$FILE_TO_COMMIT" > /dev/null 2>&1; then
  echo "â„¹ï¸  No changes to commit"
  echo "committed=false" >> "$GITHUB_OUTPUT"
  exit 0
fi

# Add and commit
git add "$FILE_TO_COMMIT"
git commit -m "$MESSAGE"

# For non-preview operations, handle the original branch logic
if [ "$OPERATION" != "update-preview" ]; then
  # Handle detached HEAD - checkout branch if needed
  if ! git symbolic-ref HEAD > /dev/null 2>&1; then
    echo "â„¹ï¸  Detached HEAD detected, checking out branch..."
    git checkout -B "$BRANCH"
  fi

  # Fetch latest changes and rebase our commit on top
  echo "ðŸ“¥ Fetching latest changes..."
  git fetch origin "$BRANCH"

  # Check if remote branch exists and has diverged
  if git rev-parse "origin/$BRANCH" > /dev/null 2>&1; then
    echo "ðŸ”„ Rebasing on latest changes..."
    if ! git rebase "origin/$BRANCH"; then
      echo "âš ï¸  Rebase conflict detected - auto-resolving with our version..."
      # Use our version for the kustomization file (it's auto-generated, ours is correct)
      git checkout --ours "$FILE_TO_COMMIT"
      git add "$FILE_TO_COMMIT"
      git rebase --continue

      # If rebase still fails, abort and try force push with lease
      if [ $? -ne 0 ]; then
        echo "âš ï¸  Rebase failed, using force-with-lease push instead..."
        git rebase --abort
        git push --force-with-lease origin "HEAD:$BRANCH"
        echo "âœ… Changes force-pushed with lease"
        echo "committed=true" >> "$GITHUB_OUTPUT"
        exit 0
      fi
    fi
  fi
fi

echo "ðŸš€ Pushing to $BRANCH..."
git push origin "HEAD:$BRANCH"

# For preview operations, switch back to the original branch
# This ensures subsequent workflow steps can find the .github/actions/ directory
if [ "$OPERATION" == "update-preview" ]; then
  echo "ðŸ”™ Switching back to original branch..."
  if [ "$ORIGINAL_BRANCH" != "detached" ]; then
    git checkout "$ORIGINAL_BRANCH"
  else
    git checkout "$ORIGINAL_REF"
  fi
fi

echo "âœ… Changes committed and pushed"
echo "committed=true" >> "$GITHUB_OUTPUT"
