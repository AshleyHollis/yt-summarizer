# =============================================================================
# Argo CD Wait with Auto-Recovery Action
# =============================================================================
# Smart wait-for-sync that detects failures and automatically recovers.
#
# Features:
#   - Detects common failure patterns (quota exceeded, invalid YAML, etc.)
#   - Auto-recovers from transient failures (missing dependencies, stuck hooks)
#   - Early detection of stuck operations (default: 120s vs 300s overall timeout)
#   - Extends timeout after recovery to allow completion (default: +120s per recovery)
#   - Provides comprehensive diagnostics on failure
#   - Max 3 recovery attempts (prevents infinite loops)
#   - 30-second cooldown between recovery attempts
#
# Failure patterns detected:
#   - QUOTA_EXCEEDED: Resource limits exceed namespace quota
#   - INVALID_YAML: Malformed YAML structure (duplicate containers, etc.)
#   - IMAGE_PULL_FAILED: Container image doesn't exist in registry
#   - MISSING_DEPENDENCY: ServiceAccount, Secret, or ConfigMap not found
#   - HOOK_TIMEOUT: Sync hook job (e.g., db-migration) stuck or failed
#   - STUCK_REFRESH: OutOfSync + Healthy + Running with refresh annotation present
#
# Auto-recovery actions:
#   - Missing dependencies: Clear stuck operation, trigger hard refresh
#   - Hook timeout: Abort stuck operation, force new sync
#   - Stuck refresh: Clear operation and re-trigger hard refresh
#   - Unknown failures: Generic recovery with operation cleanup
#
# Timeout Management:
#   - max-wait-seconds: Overall timeout (default: 300s)
#   - stuck-operation-threshold: Faster stuck detection (default: 120s)
#   - recovery-timeout-extension: Extra time per recovery (default: 120s)
#   - Example: After 2 recoveries, effective timeout = 300 + 2*120 = 540s
#
# Limitations (manual intervention required):
#   - Quota exceeded (need to increase quota or reduce requests)
#   - Invalid YAML (need to fix kustomization template)
#   - Image pull failures (need to build and push image to ACR)
#
# Usage:
#   - uses: ./.github/actions/argocd-wait
#     with:
#       app-name: preview-pr-110
#       namespace: preview-pr-110
#       max-wait-seconds: 300
#       poll-interval-seconds: 10
#       stuck-operation-threshold-seconds: 120
#       recovery-timeout-extension-seconds: 120
# =============================================================================

name: Wait for Argo CD Sync
description: Smart wait-for-sync with automatic failure detection and recovery

inputs:
  github-token:
    description: 'GitHub token for PR state checks (optional)'
    required: false
    default: ''
  app-name:
    description: 'Argo CD Application name (e.g., preview-pr-110)'
    required: true

  namespace:
    description: 'Target namespace for deployment (e.g., preview-pr-110)'
    required: true

  argocd-namespace:
    description: 'Argo CD namespace'
    required: false
    default: 'argocd'

  max-wait-seconds:
    description: 'Maximum time to wait for sync completion (seconds)'
    required: false
    default: '300'

  poll-interval-seconds:
    description: 'Interval between health checks (seconds)'
    required: false
    default: '10'

  stuck-operation-threshold-seconds:
    description: 'Time before operation is considered stuck (seconds) - faster detection than max-wait'
    required: false
    default: '120'

  recovery-timeout-extension-seconds:
    description: 'Extra timeout added after each recovery attempt (seconds)'
    required: false
    default: '120'

  max-recovery-attempts:
    description: 'Maximum number of auto-recovery attempts per failure pattern'
    required: false
    default: '3'

  recovery-cooldown-seconds:
    description: 'Cooldown period between recovery attempts (seconds)'
    required: false
    default: '30'

  fail-on-quota-exceeded:
    description: 'Fail immediately on quota exceeded errors (no recovery possible)'
    required: false
    default: 'true'

  fail-on-invalid-yaml:
    description: 'Fail immediately on invalid YAML errors (no recovery possible)'
    required: false
    default: 'true'

  cleanup-stuck-operations:
    description: 'Cleanup stuck operations before waiting (absorbs cleanup-argocd-operation)'
    required: false
    default: 'false'

  auto-recovery:
    description: 'Enable auto-recovery features (disable for simple wait behavior)'
    required: false
    default: 'true'

  pr-number:
    description: 'Pull request number for diagnostics (legacy wait-for-argocd compat, use "0" for prod)'
    required: false
    default: ''

  expected-image-tag:
    description: 'Expected image tag to verify before declaring sync successful (prevents race conditions)'
    required: false
    default: ''

outputs:
  sync-status:
    description: 'Final sync status (Synced, OutOfSync, Failed, Unknown)'
    value: ${{ steps.wait.outputs.sync-status }}

  health-status:
    description: 'Final health status (Healthy, Progressing, Degraded, Missing, Suspended, Unknown)'
    value: ${{ steps.wait.outputs.health-status }}

  recovery-attempts:
    description: 'Number of recovery attempts performed'
    value: ${{ steps.wait.outputs.recovery-attempts }}

  failure-pattern:
    description: 'Detected failure pattern (if any)'
    value: ${{ steps.wait.outputs.failure-pattern }}

runs:
  using: composite
  steps:
    - name: Cleanup stuck operations (optional)
      if: inputs.cleanup-stuck-operations == 'true'
      shell: bash
      env:
        APP_NAME: ${{ inputs.app-name }}
        ARGOCD_NAMESPACE: ${{ inputs.argocd-namespace }}
        TIMEOUT_THRESHOLD: ${{ inputs.max-wait-seconds }}
      run: |
        echo "ðŸ” Checking for stuck operations on $APP_NAME..."

        OPERATION_STATE=$(kubectl get application "$APP_NAME" -n "$ARGOCD_NAMESPACE" \
          -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "None")

        if [[ "$OPERATION_STATE" == "Running" ]]; then
          echo "âš ï¸  Cleaning up stuck operation..."
          kubectl patch application "$APP_NAME" -n "$ARGOCD_NAMESPACE" \
            --type merge -p '{"operation":null}' 2>/dev/null || true
          sleep 3
          echo "âœ… Cleanup complete"
        else
          echo "âœ… No stuck operations"
        fi

    - name: Wait for Argo CD sync with auto-recovery
      id: wait
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        APP_NAME: ${{ inputs.app-name }}
        NAMESPACE: ${{ inputs.namespace }}
        ARGOCD_NAMESPACE: ${{ inputs.argocd-namespace }}
        MAX_WAIT_SECONDS: ${{ inputs.max-wait-seconds }}
        MAX_SYNC_DURATION: ${{ inputs.max-wait-seconds }}
        POLL_INTERVAL_SECONDS: ${{ inputs.poll-interval-seconds }}
        OPERATION_CHECK_INTERVAL: ${{ inputs.poll-interval-seconds }}
        STUCK_OPERATION_THRESHOLD: ${{ inputs.stuck-operation-threshold-seconds }}
        RECOVERY_TIMEOUT_EXTENSION: ${{ inputs.recovery-timeout-extension-seconds }}
        MAX_RECOVERY_ATTEMPTS: ${{ inputs.max-recovery-attempts }}
        RECOVERY_COOLDOWN_SECONDS: ${{ inputs.recovery-cooldown-seconds }}
        FAIL_ON_QUOTA_EXCEEDED: ${{ inputs.fail-on-quota-exceeded }}
        FAIL_ON_INVALID_YAML: ${{ inputs.fail-on-invalid-yaml }}
        AUTO_RECOVERY: ${{ inputs.auto-recovery }}
        PR_NUMBER: ${{ inputs.pr-number }}
        EXPECTED_IMAGE_TAG: ${{ inputs.expected-image-tag }}
      run: |
        set -euo pipefail

        echo "::group::â³ Waiting for Argo CD Sync"
        echo "Application: $APP_NAME"
        echo "Namespace: $NAMESPACE"
        echo "Argo CD Namespace: $ARGOCD_NAMESPACE"
        echo "Max wait: ${MAX_WAIT_SECONDS}s"
        echo "Poll interval: ${POLL_INTERVAL_SECONDS}s"
        echo "Auto-recovery: $AUTO_RECOVERY"
        if [[ -n "${EXPECTED_IMAGE_TAG}" ]]; then
          echo "Expected image tag: $EXPECTED_IMAGE_TAG"
        fi
        if [[ "$AUTO_RECOVERY" == "true" ]]; then
          echo "Max recovery attempts: $MAX_RECOVERY_ATTEMPTS"
          echo "Recovery cooldown: ${RECOVERY_COOLDOWN_SECONDS}s"
        fi
        echo "::endgroup::"
        echo ""

        # Source the auto-recovery script
        source "${{ github.action_path }}/../../../scripts/ci/lib/argocd-utils.sh"

        # Call wait_for_sync with auto-recovery
        if wait_for_sync "$APP_NAME" "$NAMESPACE" "$MAX_WAIT_SECONDS" "$POLL_INTERVAL_SECONDS"; then
          echo ""
          echo "sync-status=Synced" >> "$GITHUB_OUTPUT"
          echo "health-status=Healthy" >> "$GITHUB_OUTPUT"
          echo "recovery-attempts=0" >> "$GITHUB_OUTPUT"
          echo "âœ… Deployment successful!"
          exit 0
        else
          echo ""
          echo "::error::Deployment failed or timed out. See logs above for details."

          # Get final status for output
          SYNC_STATUS=$(kubectl get application "$APP_NAME" -n "$ARGOCD_NAMESPACE" \
            -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application "$APP_NAME" -n "$ARGOCD_NAMESPACE" \
            -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")

          echo "sync-status=$SYNC_STATUS" >> "$GITHUB_OUTPUT"
          echo "health-status=$HEALTH_STATUS" >> "$GITHUB_OUTPUT"

          exit 1
        fi
